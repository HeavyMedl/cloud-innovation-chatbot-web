"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _debounce = _interopRequireDefault(require("./debounce"));

var _memoize = _interopRequireDefault(require("./memoize"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var ScrollSpy =
/*#__PURE__*/
function (_React$Component) {
  _inherits(ScrollSpy, _React$Component);

  function ScrollSpy(props, context) {
    var _this;

    _classCallCheck(this, ScrollSpy);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScrollSpy).call(this, props, context));
    _this.handlePointerOver = (0, _debounce.default)(_this.handlePointerOver.bind(_assertThisInitialized(_assertThisInitialized(_this))), 300);
    _this.handleScroll = _this.handleScroll.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.emitScroll = (0, _memoize.default)(function (initial, fraction, width) {
      _this.props.onScroll && _this.props.onScroll({
        initial: initial,
        fraction: fraction,
        width: width
      });
    });
    return _this;
  }

  _createClass(ScrollSpy, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props$targetRef = this.props.targetRef;
      _this$props$targetRef = _this$props$targetRef === void 0 ? {} : _this$props$targetRef;
      var current = _this$props$targetRef.current;

      if (current) {
        current.addEventListener('pointerover', this.handlePointerOver, {
          passive: true
        });
        current.addEventListener('scroll', this.handleScroll, {
          passive: true
        });
        this.emitInitialScrollEvent(current);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.targetRef !== this.props.targetRef) {
        var _prevProps$targetRef = prevProps.targetRef;
        _prevProps$targetRef = _prevProps$targetRef === void 0 ? {} : _prevProps$targetRef;
        var prevCurrent = _prevProps$targetRef.current;
        var _this$props$targetRef2 = this.props.targetRef;
        _this$props$targetRef2 = _this$props$targetRef2 === void 0 ? {} : _this$props$targetRef2;
        var current = _this$props$targetRef2.current;

        if (prevCurrent) {
          prevCurrent.removeEventListener('pointerover', this.handlePointerOver);
          prevCurrent.removeEventListener('scroll', this.handleScroll);
        }

        if (current) {
          current.addEventListener('pointerover', this.handlePointerOver, {
            passive: true
          });
          current.addEventListener('scroll', this.handleScroll, {
            passive: true
          });
          this.emitInitialScrollEvent(current);
        }
      }
    }
  }, {
    key: "emitInitialScrollEvent",
    value: function emitInitialScrollEvent(current, waited) {
      var _this2 = this;

      if (!waited && current.scrollWidth === current.offsetWidth) {
        // HACK: Chrome 66 will initially say scrollWidth equals to offsetWidth, until some time later
        setTimeout(function () {
          return _this2.emitInitialScrollEvent(current, true);
        });
      }

      this.handleScroll({
        target: current
      }, true);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$props$targetRef3 = this.props.targetRef;
      _this$props$targetRef3 = _this$props$targetRef3 === void 0 ? {} : _this$props$targetRef3;
      var current = _this$props$targetRef3.current;
      current && current.removeEventListener('scroll', this.handleScroll);
    }
  }, {
    key: "handlePointerOver",
    value: function handlePointerOver() {
      // We need to send "onScroll" because "scrollWidth" might have changed
      // For example, the container resized, the scroll width will be incorrect
      // We will debounce to prevent "pointerOver" calculating too often
      // We will memoize to prevent firing unnecessary "onScroll"
      var _this$props$targetRef4 = this.props.targetRef;
      _this$props$targetRef4 = _this$props$targetRef4 === void 0 ? {} : _this$props$targetRef4;
      var current = _this$props$targetRef4.current;
      this.handleScroll({
        target: current
      });
    }
  }, {
    key: "handleScroll",
    value: function handleScroll(_ref) {
      var target = _ref.target;
      var initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var offsetWidth = target.offsetWidth,
          scrollLeft = target.scrollLeft,
          scrollWidth = target.scrollWidth;
      this.emitScroll(initial, "".concat(scrollWidth === offsetWidth ? 0 : scrollLeft / (scrollWidth - offsetWidth) * 100, "%"), "".concat(offsetWidth / scrollWidth * 100, "%"));
    }
  }, {
    key: "render",
    value: function render() {
      return false;
    }
  }]);

  return ScrollSpy;
}(_react.default.Component);

exports.default = ScrollSpy;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TY3JvbGxTcHkuanMiXSwibmFtZXMiOlsiU2Nyb2xsU3B5IiwicHJvcHMiLCJjb250ZXh0IiwiaGFuZGxlUG9pbnRlck92ZXIiLCJiaW5kIiwiaGFuZGxlU2Nyb2xsIiwiZW1pdFNjcm9sbCIsImluaXRpYWwiLCJmcmFjdGlvbiIsIndpZHRoIiwib25TY3JvbGwiLCJ0YXJnZXRSZWYiLCJjdXJyZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJlbWl0SW5pdGlhbFNjcm9sbEV2ZW50IiwicHJldlByb3BzIiwicHJldkN1cnJlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwid2FpdGVkIiwic2Nyb2xsV2lkdGgiLCJvZmZzZXRXaWR0aCIsInNldFRpbWVvdXQiLCJ0YXJnZXQiLCJzY3JvbGxMZWZ0IiwiUmVhY3QiLCJDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUVxQkEsUzs7Ozs7QUFDbkIscUJBQVlDLEtBQVosRUFBbUJDLE9BQW5CLEVBQTRCO0FBQUE7O0FBQUE7O0FBQzFCLG1GQUFNRCxLQUFOLEVBQWFDLE9BQWI7QUFFQSxVQUFLQyxpQkFBTCxHQUF5Qix1QkFBUyxNQUFLQSxpQkFBTCxDQUF1QkMsSUFBdkIsdURBQVQsRUFBNEMsR0FBNUMsQ0FBekI7QUFDQSxVQUFLQyxZQUFMLEdBQW9CLE1BQUtBLFlBQUwsQ0FBa0JELElBQWxCLHVEQUFwQjtBQUVBLFVBQUtFLFVBQUwsR0FBa0Isc0JBQVEsVUFBQ0MsT0FBRCxFQUFVQyxRQUFWLEVBQW9CQyxLQUFwQixFQUE4QjtBQUN0RCxZQUFLUixLQUFMLENBQVdTLFFBQVgsSUFBdUIsTUFBS1QsS0FBTCxDQUFXUyxRQUFYLENBQW9CO0FBQUVILFFBQUFBLE9BQU8sRUFBUEEsT0FBRjtBQUFXQyxRQUFBQSxRQUFRLEVBQVJBLFFBQVg7QUFBcUJDLFFBQUFBLEtBQUssRUFBTEE7QUFBckIsT0FBcEIs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LE1BRFQsQ0FDbkJDLFVBRG1CO0FBQUEsVUFDUEosV0FETyxHQUNTRyxNQURULENBQ1BILFdBRE87QUFHeEMsV0FBS2QsVUFBTCxDQUNFQyxPQURGLFlBRU1hLFdBQVcsS0FBS0MsV0FBaEIsR0FBOEIsQ0FBOUIsR0FBa0NHLFVBQVUsSUFBSUosV0FBVyxHQUFHQyxXQUFsQixDQUFWLEdBQTJDLEdBRm5GLGtCQUdNQSxXQUFXLEdBQUdELFdBQWQsR0FBNEIsR0FIbEM7QUFLRDs7OzZCQUVRO0FBQ1AsYUFBTyxLQUFQO0FBQ0Q7Ozs7RUE3RW9DSyxlQUFNQyxTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vZGVib3VuY2UnO1xuaW1wb3J0IG1lbW9pemUgZnJvbSAnLi9tZW1vaXplJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsU3B5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG5cbiAgICB0aGlzLmhhbmRsZVBvaW50ZXJPdmVyID0gZGVib3VuY2UodGhpcy5oYW5kbGVQb2ludGVyT3Zlci5iaW5kKHRoaXMpLCAzMDApO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsID0gdGhpcy5oYW5kbGVTY3JvbGwuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZW1pdFNjcm9sbCA9IG1lbW9pemUoKGluaXRpYWwsIGZyYWN0aW9uLCB3aWR0aCkgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vblNjcm9sbCAmJiB0aGlzLnByb3BzLm9uU2Nyb2xsKHsgaW5pdGlhbCwgZnJhY3Rpb24sIHdpZHRoIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyB0YXJnZXRSZWY6IHsgY3VycmVudCB9ID0ge30gfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoY3VycmVudCkge1xuICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyb3ZlcicsIHRoaXMuaGFuZGxlUG9pbnRlck92ZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIHRoaXMuZW1pdEluaXRpYWxTY3JvbGxFdmVudChjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKHByZXZQcm9wcy50YXJnZXRSZWYgIT09IHRoaXMucHJvcHMudGFyZ2V0UmVmKSB7XG4gICAgICBjb25zdCB7IHRhcmdldFJlZjogeyBjdXJyZW50OiBwcmV2Q3VycmVudCB9ID0ge30gfSA9IHByZXZQcm9wcztcbiAgICAgIGNvbnN0IHsgdGFyZ2V0UmVmOiB7IGN1cnJlbnQgfSA9IHt9IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICBpZiAocHJldkN1cnJlbnQpIHtcbiAgICAgICAgcHJldkN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm92ZXInLCB0aGlzLmhhbmRsZVBvaW50ZXJPdmVyKTtcbiAgICAgICAgcHJldkN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJvdmVyJywgdGhpcy5oYW5kbGVQb2ludGVyT3ZlciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZW1pdEluaXRpYWxTY3JvbGxFdmVudChjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbWl0SW5pdGlhbFNjcm9sbEV2ZW50KGN1cnJlbnQsIHdhaXRlZCkge1xuICAgIGlmICghd2FpdGVkICYmIGN1cnJlbnQuc2Nyb2xsV2lkdGggPT09IGN1cnJlbnQub2Zmc2V0V2lkdGgpIHtcbiAgICAgIC8vIEhBQ0s6IENocm9tZSA2NiB3aWxsIGluaXRpYWxseSBzYXkgc2Nyb2xsV2lkdGggZXF1YWxzIHRvIG9mZnNldFdpZHRoLCB1bnRpbCBzb21lIHRpbWUgbGF0ZXJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5lbWl0SW5pdGlhbFNjcm9sbEV2ZW50KGN1cnJlbnQsIHRydWUpKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZVNjcm9sbCh7IHRhcmdldDogY3VycmVudCB9LCB0cnVlKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNvbnN0IHsgdGFyZ2V0UmVmOiB7IGN1cnJlbnQgfSA9IHt9IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY3VycmVudCAmJiBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJPdmVyKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gc2VuZCBcIm9uU2Nyb2xsXCIgYmVjYXVzZSBcInNjcm9sbFdpZHRoXCIgbWlnaHQgaGF2ZSBjaGFuZ2VkXG4gICAgLy8gRm9yIGV4YW1wbGUsIHRoZSBjb250YWluZXIgcmVzaXplZCwgdGhlIHNjcm9sbCB3aWR0aCB3aWxsIGJlIGluY29ycmVjdFxuICAgIC8vIFdlIHdpbGwgZGVib3VuY2UgdG8gcHJldmVudCBcInBvaW50ZXJPdmVyXCIgY2FsY3VsYXRpbmcgdG9vIG9mdGVuXG4gICAgLy8gV2Ugd2lsbCBtZW1vaXplIHRvIHByZXZlbnQgZmlyaW5nIHVubmVjZXNzYXJ5IFwib25TY3JvbGxcIlxuICAgIGNvbnN0IHsgdGFyZ2V0UmVmOiB7IGN1cnJlbnQgfSA9IHt9IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5oYW5kbGVTY3JvbGwoeyB0YXJnZXQ6IGN1cnJlbnQgfSk7XG4gIH1cblxuICBoYW5kbGVTY3JvbGwoeyB0YXJnZXQgfSwgaW5pdGlhbCA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBvZmZzZXRXaWR0aCwgc2Nyb2xsTGVmdCwgc2Nyb2xsV2lkdGggfSA9IHRhcmdldDtcblxuICAgIHRoaXMuZW1pdFNjcm9sbChcbiAgICAgIGluaXRpYWwsXG4gICAgICBgJHsgc2Nyb2xsV2lkdGggPT09IG9mZnNldFdpZHRoID8gMCA6IHNjcm9sbExlZnQgLyAoc2Nyb2xsV2lkdGggLSBvZmZzZXRXaWR0aCkgKiAxMDAgfSVgLFxuICAgICAgYCR7IG9mZnNldFdpZHRoIC8gc2Nyb2xsV2lkdGggKiAxMDAgfSVgXG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiJdfQ==