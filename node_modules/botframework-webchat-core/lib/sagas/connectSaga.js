"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _callee2;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _effects = require("redux-saga/effects");

var _forkPut = _interopRequireDefault(require("./effects/forkPut"));

var _jsonwebtoken = require("jsonwebtoken");

var _mathRandom = _interopRequireDefault(require("math-random"));

var _updateConnectionStatus = _interopRequireWildcard(require("../actions/updateConnectionStatus"));

var _createPromiseQueue = _interopRequireDefault(require("../createPromiseQueue"));

var _botframeworkDirectlinejs = require("botframework-directlinejs");

var _connect = require("../actions/connect");

var _disconnect = require("../actions/disconnect");

var _reconnect = require("../actions/reconnect");

var _marked =
/*#__PURE__*/
_regenerator["default"].mark(observeAndPutConnectionStatusUpdate),
    _marked2 =
/*#__PURE__*/
_regenerator["default"].mark(connectSaga),
    _marked3 =
/*#__PURE__*/
_regenerator["default"].mark(reconnectSaga),
    _marked4 =
/*#__PURE__*/
_regenerator["default"].mark(runAsyncEffect),
    _marked5 =
/*#__PURE__*/
_regenerator["default"].mark(takeDisconnectAsError),
    _marked6 =
/*#__PURE__*/
_regenerator["default"].mark(_callee2);

var CONNECTING = _botframeworkDirectlinejs.ConnectionStatus.Connecting,
    ONLINE = _botframeworkDirectlinejs.ConnectionStatus.Online,
    UNINITIALIZED = _botframeworkDirectlinejs.ConnectionStatus.Uninitialized;

function randomUserID() {
  return "r_".concat((0, _mathRandom["default"])().toString(36).substr(2, 10));
}

function observeAndPutConnectionStatusUpdate(directLine) {
  var connectionStatusQueue, connectionStatusSubscription, connectionStatus;
  return _regenerator["default"].wrap(function observeAndPutConnectionStatusUpdate$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          connectionStatusQueue = (0, _createPromiseQueue["default"])();
          connectionStatusSubscription = directLine.connectionStatus$.subscribe({
            next: connectionStatusQueue.push
          });
          _context.prev = 2;

        case 3:
          _context.next = 5;
          return (0, _effects.call)(connectionStatusQueue.shift);

        case 5:
          connectionStatus = _context.sent;
          _context.next = 8;
          return (0, _effects.put)((0, _updateConnectionStatus["default"])(connectionStatus));

        case 8:
          _context.next = 3;
          break;

        case 10:
          _context.prev = 10;
          connectionStatusSubscription.unsubscribe();
          return _context.finish(10);

        case 13:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[2,, 10, 13]]);
}

function rectifyUserID(directLine, userIDFromAction) {
  var token = directLine.token;

  var _ref = (0, _jsonwebtoken.decode)(token) || {},
      userIDFromToken = _ref.user;

  if (userIDFromToken) {
    if (userIDFromAction && userIDFromAction !== userIDFromToken) {
      console.warn('Web Chat: user ID is both specified in the Direct Line token and passed in, will use the user ID from the token.');
    }

    return userIDFromToken;
  } else if (userIDFromAction) {
    if (typeof userIDFromAction !== 'string') {
      console.warn('Web Chat: user ID must be a string.');
      return randomUserID();
    } else if (/^dl_/.test(userIDFromAction)) {
      console.warn('Web Chat: user ID prefixed with "dl_" is reserved and must be embedded into the Direct Line token to prevent forgery.');
      return randomUserID();
    }
  } else {
    return randomUserID();
  }

  return userIDFromAction;
} // We could make this a Promise instead of saga (function generator) to make the code cleaner, if:
// 1. We found a way to cancel Promise
// 2. subscribe() are shared amongst all subscriptions, e.g. turn Observable into events


function connectSaga(directLine) {
  var activitySubscription, unsubscribeActivity, _ref2, connectionStatus;

  return _regenerator["default"].wrap(function connectSaga$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          // DirectLineJS starts the connection only after the first subscriber for activity$, not connectionStatus$
          activitySubscription = directLine.activity$.subscribe({
            next: function next() {
              return 0;
            }
          });
          unsubscribeActivity = activitySubscription.unsubscribe.bind(activitySubscription);
          _context2.prev = 2;

        case 3:
          _context2.next = 5;
          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);

        case 5:
          _ref2 = _context2.sent;
          connectionStatus = _ref2.payload.connectionStatus;

          if (!(connectionStatus === ONLINE)) {
            _context2.next = 11;
            break;
          }

          return _context2.abrupt("return", function () {
            unsubscribeActivity();
            directLine.end();
          });

        case 11:
          if (!(connectionStatus !== UNINITIALIZED && connectionStatus !== CONNECTING)) {
            _context2.next = 13;
            break;
          }

          throw new Error("Failed to connect, DirectLineJS returned ".concat(connectionStatus, "."));

        case 13:
          _context2.next = 3;
          break;

        case 15:
          _context2.next = 21;
          break;

        case 17:
          _context2.prev = 17;
          _context2.t0 = _context2["catch"](2);
          // We will unsubscribe if we failed to connect or got cancelled only.
          // We should not unsubscribe in happy case, because DirectLineJS should relying on the subscription to connect/disconnect.
          unsubscribeActivity();
          throw _context2.t0;

        case 21:
          _context2.prev = 21;
          _context2.next = 24;
          return (0, _effects.cancelled)();

        case 24:
          if (!_context2.sent) {
            _context2.next = 26;
            break;
          }

          unsubscribeActivity();

        case 26:
          return _context2.finish(21);

        case 27:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[2, 17, 21, 27]]);
}

function reconnectSaga() {
  var _ref3, _connectionStatus;

  return _regenerator["default"].wrap(function reconnectSaga$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);

        case 2:
          _ref3 = _context3.sent;
          _connectionStatus = _ref3.payload.connectionStatus;

          if (!(_connectionStatus === ONLINE)) {
            _context3.next = 8;
            break;
          }

          return _context3.abrupt("break", 12);

        case 8:
          if (!(_connectionStatus !== CONNECTING)) {
            _context3.next = 10;
            break;
          }

          throw new Error("Failed to reconnect. DirectLineJS returned ".concat(_connectionStatus, "."));

        case 10:
          _context3.next = 0;
          break;

        case 12:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
} // This is similar to behavior of redux-promise-middleware, but using saga instead of Promise.
// We guarantee PENDING -> FULFILLING -> FULFILLED, or PENDING -> REJECTED. This will help us simplify logic in other part of code.
// Note that after the saga is cancelled, subsequent call to put() will be ignored silently.


function runAsyncEffect(_ref4, callEffectFactory) {
  var type, meta, payload, result;
  return _regenerator["default"].wrap(function runAsyncEffect$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          type = _ref4.type, meta = _ref4.meta, payload = _ref4.payload;
          _context4.prev = 1;
          _context4.next = 4;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_PENDING"),
            meta: meta,
            payload: payload
          });

        case 4:
          _context4.next = 6;
          return callEffectFactory();

        case 6:
          result = _context4.sent;
          _context4.next = 9;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_FULFILLING"),
            meta: meta,
            payload: payload
          }, {
            type: "".concat(type, "_FULFILLED"),
            meta: meta,
            payload: payload
          });

        case 9:
          return _context4.abrupt("return", result);

        case 12:
          _context4.prev = 12;
          _context4.t0 = _context4["catch"](1);
          _context4.next = 16;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_REJECTED"),
            error: true,
            meta: meta,
            payload: _context4.t0
          });

        case 16:
          throw _context4.t0;

        case 17:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, null, [[1, 12]]);
}

function takeDisconnectAsError() {
  return _regenerator["default"].wrap(function takeDisconnectAsError$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _effects.take)(_disconnect.DISCONNECT);

        case 2:
          throw new Error('disconnected');

        case 3:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5);
}

function runAsyncEffectUntilDisconnect(baseAction, callEffectFactory) {
  // We cannot use saga cancel() here, because cancelling saga will prohibit us from sending *_REJECTED.
  // Without REJECTED, it impacts our assumptions around PENDING/FULFILLED/REJECTED.
  return runAsyncEffect(baseAction,
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee() {
    var _ref5, result;

    return _regenerator["default"].wrap(function _callee$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return (0, _effects.race)({
              _: takeDisconnectAsError(),
              result: callEffectFactory()
            });

          case 2:
            _ref5 = _context6.sent;
            result = _ref5.result;
            return _context6.abrupt("return", result);

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee);
  }));
}

function _callee2() {
  var _loop;

  return _regenerator["default"].wrap(function _callee2$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _loop =
          /*#__PURE__*/
          _regenerator["default"].mark(function _loop() {
            var _ref6, _ref6$payload, directLine, userIDFromAction, username, updateConnectionStatusTask, disconnectMeta, meta, endDirectLine, _ref7, _ref7$updateConnectio, _ref7$updateConnectio2, _connectionStatus2;

            return _regenerator["default"].wrap(function _loop$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return (0, _effects.take)(_connect.CONNECT);

                  case 2:
                    _ref6 = _context7.sent;
                    _ref6$payload = _ref6.payload;
                    directLine = _ref6$payload.directLine;
                    userIDFromAction = _ref6$payload.userID;
                    username = _ref6$payload.username;
                    _context7.next = 9;
                    return (0, _effects.fork)(observeAndPutConnectionStatusUpdate, directLine);

                  case 9:
                    updateConnectionStatusTask = _context7.sent;
                    disconnectMeta = void 0; // TODO: [P2] Checks if this attached subtask will get killed if the parent task is complete (peacefully), errored out, or cancelled.

                    meta = {
                      userID: rectifyUserID(directLine, userIDFromAction),
                      username: username
                    }; // We will dispatch CONNECT_PENDING, wait for connect completed, errored, or cancelled (thru disconnect).
                    // Then dispatch CONNECT_FULFILLED/CONNECT_REJECTED as needed.

                    _context7.prev = 12;
                    _context7.next = 15;
                    return runAsyncEffectUntilDisconnect({
                      type: _connect.CONNECT,
                      meta: meta,
                      payload: {
                        directLine: directLine
                      }
                    }, function () {
                      return (0, _effects.call)(connectSaga, directLine);
                    });

                  case 15:
                    endDirectLine = _context7.sent;
                    _context7.prev = 16;

                  case 17:
                    _context7.next = 19;
                    return (0, _effects.race)({
                      _: (0, _effects.take)(_disconnect.DISCONNECT),
                      updateConnectionStatusAction: (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS)
                    });

                  case 19:
                    _ref7 = _context7.sent;
                    _ref7$updateConnectio = _ref7.updateConnectionStatusAction;
                    _ref7$updateConnectio = _ref7$updateConnectio === void 0 ? {} : _ref7$updateConnectio;
                    _ref7$updateConnectio2 = _ref7$updateConnectio.payload;
                    _ref7$updateConnectio2 = _ref7$updateConnectio2 === void 0 ? {} : _ref7$updateConnectio2;
                    _connectionStatus2 = _ref7$updateConnectio2.connectionStatus; // If it is not disconnect action, connectionStatus will not be undefined.

                    if (!(_connectionStatus2 === CONNECTING)) {
                      _context7.next = 30;
                      break;
                    }

                    _context7.next = 28;
                    return runAsyncEffectUntilDisconnect({
                      type: _reconnect.RECONNECT,
                      meta: meta,
                      payload: {
                        directLine: directLine
                      }
                    }, function () {
                      return (0, _effects.call)(reconnectSaga);
                    });

                  case 28:
                    _context7.next = 36;
                    break;

                  case 30:
                    if (!(_connectionStatus2 !== ONLINE)) {
                      _context7.next = 36;
                      break;
                    }

                    if (!(typeof _connectionStatus2 !== 'undefined')) {
                      _context7.next = 35;
                      break;
                    }

                    throw new Error("Connection status changed to ".concat(_connectionStatus2));

                  case 35:
                    return _context7.abrupt("break", 38);

                  case 36:
                    _context7.next = 17;
                    break;

                  case 38:
                    _context7.prev = 38;
                    endDirectLine();
                    return _context7.finish(38);

                  case 41:
                    _context7.next = 46;
                    break;

                  case 43:
                    _context7.prev = 43;
                    _context7.t0 = _context7["catch"](12);
                    disconnectMeta = {
                      error: _context7.t0
                    };

                  case 46:
                    _context7.prev = 46;
                    _context7.next = 49;
                    return (0, _effects.cancel)(updateConnectionStatusTask);

                  case 49:
                    _context7.next = 51;
                    return (0, _forkPut["default"])({
                      type: _disconnect.DISCONNECT_PENDING,
                      meta: disconnectMeta,
                      payload: {
                        directLine: directLine
                      }
                    }, {
                      type: _disconnect.DISCONNECT_FULFILLED,
                      meta: disconnectMeta,
                      payload: {
                        directLine: directLine
                      }
                    });

                  case 51:
                    return _context7.finish(46);

                  case 52:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _loop, null, [[12, 43, 46, 52], [16,, 38, 41]]);
          });

        case 1:
          return _context8.delegateYield(_loop(), "t0", 2);

        case 2:
          _context8.next = 1;
          break;

        case 4:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked6);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zYWdhcy9jb25uZWN0U2FnYS5qcyJdLCJuYW1lcyI6WyJvYnNlcnZlQW5kUHV0Q29ubmVjdGlvblN0YXR1c1VwZGF0ZSIsImNvbm5lY3RTYWdhIiwicmVjb25uZWN0U2FnYSIsInJ1bkFzeW5jRWZmZWN0IiwidGFrZURpc2Nvbm5lY3RBc0Vycm9yIiwiQ09OTkVDVElORyIsIkNvbm5lY3Rpb25TdGF0dXMiLCJDb25uZWN0aW5nIiwiT05MSU5FIiwiT25saW5lIiwiVU5JTklUSUFMSVpFRCIsIlVuaW5pdGlhbGl6ZWQiLCJyYW5kb21Vc2VySUQiLCJ0b1N0cmluZyIsInN1YnN0ciIsImRpcmVjdExpbmUiLCJjb25uZWN0aW9uU3RhdHVzUXVldWUiLCJjb25uZWN0aW9uU3RhdHVzU3Vic2NyaXB0aW9uIiwiY29ubmVjdGlvblN0YXR1cyQiLCJzdWJzY3JpYmUiLCJuZXh0IiwicHVzaCIsInNoaWZ0IiwiY29ubmVjdGlvblN0YXR1cyIsInVuc3Vic2NyaWJlIiwicmVjdGlmeVVzZXJJRCIsInVzZXJJREZyb21BY3Rpb24iLCJ0b2tlbiIsInVzZXJJREZyb21Ub2tlbiIsInVzZXIiLCJjb25zb2xlIiwid2FybiIsInRlc3QiLCJhY3Rpdml0eVN1YnNjcmlwdGlvbiIsImFjdGl2aXR5JCIsInVuc3Vic2NyaWJlQWN0aXZpdHkiLCJiaW5kIiwiVVBEQVRFX0NPTk5FQ1RJT05fU1RBVFVTIiwicGF5bG9hZCIsImVuZCIsIkVycm9yIiwiY2FsbEVmZmVjdEZhY3RvcnkiLCJ0eXBlIiwibWV0YSIsInJlc3VsdCIsImVycm9yIiwiRElTQ09OTkVDVCIsInJ1bkFzeW5jRWZmZWN0VW50aWxEaXNjb25uZWN0IiwiYmFzZUFjdGlvbiIsIl8iLCJDT05ORUNUIiwidXNlcklEIiwidXNlcm5hbWUiLCJ1cGRhdGVDb25uZWN0aW9uU3RhdHVzVGFzayIsImRpc2Nvbm5lY3RNZXRhIiwiZW5kRGlyZWN0TGluZSIsInVwZGF0ZUNvbm5lY3Rpb25TdGF0dXNBY3Rp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QTtBQUFBO0FBaUVQZ0Msb0JBQUFBLGFBQWE7QUFqRU47O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQW9FVEQsb0JBQUFBLGNBQWMsR0FBRztBQUFFVCxzQkFBQUEsS0FBSztBQUFQLHFCQUFqQjs7QUFwRVM7QUFBQTtBQUFBO0FBc0VULDJCQUFNLHFCQUFPUSwwQkFBUCxDQUFOOztBQXRFUztBQUFBO0FBMEVULDJCQUFNLHlCQUNKO0FBQUVYLHNCQUFBQSxJQUFJLEVBQUVnQiw4QkFBUjtBQUE0QmYsc0JBQUFBLElBQUksRUFBRVcsY0FBbEM7QUFBa0RoQixzQkFBQUEsT0FBTyxFQUFFO0FBQUV2Qix3QkFBQUEsVUFBVSxFQUFWQTtBQUFGO0FBQTNELHFCQURJLEVBRUo7QUFBRTJCLHNCQUFBQSxJQUFJLEVBQUVpQixnQ0FBUjtBQUE4QmhCLHNCQUFBQSxJQUFJLEVBQUVXLGNBQXBDO0FBQW9EaEIsc0JBQUFBLE9BQU8sRUFBRTtBQUFFdkIsd0JBQUFBLFVBQVUsRUFBVkE7QUFBRjtBQUE3RCxxQkFGSSxDQUFOOztBQTFFUztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgY2FsbCxcbiAgY2FuY2VsLFxuICBjYW5jZWxsZWQsXG4gIGZvcmssXG4gIHB1dCxcbiAgcmFjZSxcbiAgdGFrZSxcbn0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcblxuaW1wb3J0IGZvcmtQdXQgZnJvbSAnLi9lZmZlY3RzL2ZvcmtQdXQnO1xuXG5pbXBvcnQgeyBkZWNvZGUgfSBmcm9tICdqc29ud2VidG9rZW4nO1xuaW1wb3J0IHJhbmRvbSBmcm9tICdtYXRoLXJhbmRvbSc7XG5cbmltcG9ydCB1cGRhdGVDb25uZWN0aW9uU3RhdHVzLCB7IFVQREFURV9DT05ORUNUSU9OX1NUQVRVUyB9IGZyb20gJy4uL2FjdGlvbnMvdXBkYXRlQ29ubmVjdGlvblN0YXR1cyc7XG5cbmltcG9ydCBjcmVhdGVQcm9taXNlUXVldWUgZnJvbSAnLi4vY3JlYXRlUHJvbWlzZVF1ZXVlJztcblxuaW1wb3J0IHsgQ29ubmVjdGlvblN0YXR1cyB9IGZyb20gJ2JvdGZyYW1ld29yay1kaXJlY3RsaW5lanMnO1xuXG5pbXBvcnQgeyBDT05ORUNUIH0gZnJvbSAnLi4vYWN0aW9ucy9jb25uZWN0JztcblxuaW1wb3J0IHtcbiAgRElTQ09OTkVDVCxcbiAgRElTQ09OTkVDVF9QRU5ESU5HLFxuICBESVNDT05ORUNUX0ZVTEZJTExFRFxufSBmcm9tICcuLi9hY3Rpb25zL2Rpc2Nvbm5lY3QnO1xuXG5pbXBvcnQgeyBSRUNPTk5FQ1QgfSBmcm9tICcuLi9hY3Rpb25zL3JlY29ubmVjdCc7XG5cbmNvbnN0IHtcbiAgQ29ubmVjdGluZzogQ09OTkVDVElORyxcbiAgT25saW5lOiBPTkxJTkUsXG4gIFVuaW5pdGlhbGl6ZWQ6IFVOSU5JVElBTElaRURcbn0gPSBDb25uZWN0aW9uU3RhdHVzO1xuXG5mdW5jdGlvbiByYW5kb21Vc2VySUQoKSB7XG4gIHJldHVybiBgcl8keyByYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDEwKSB9YDtcbn1cblxuZnVuY3Rpb24qIG9ic2VydmVBbmRQdXRDb25uZWN0aW9uU3RhdHVzVXBkYXRlKGRpcmVjdExpbmUpIHtcbiAgY29uc3QgY29ubmVjdGlvblN0YXR1c1F1ZXVlID0gY3JlYXRlUHJvbWlzZVF1ZXVlKCk7XG4gIGNvbnN0IGNvbm5lY3Rpb25TdGF0dXNTdWJzY3JpcHRpb24gPSBkaXJlY3RMaW5lLmNvbm5lY3Rpb25TdGF0dXMkLnN1YnNjcmliZSh7IG5leHQ6IGNvbm5lY3Rpb25TdGF0dXNRdWV1ZS5wdXNoIH0pO1xuXG4gIHRyeSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgY29ubmVjdGlvblN0YXR1cyA9IHlpZWxkIGNhbGwoY29ubmVjdGlvblN0YXR1c1F1ZXVlLnNoaWZ0KTtcblxuICAgICAgeWllbGQgcHV0KHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXMoY29ubmVjdGlvblN0YXR1cykpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBjb25uZWN0aW9uU3RhdHVzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdGlmeVVzZXJJRChkaXJlY3RMaW5lLCB1c2VySURGcm9tQWN0aW9uKSB7XG4gIGNvbnN0IHsgdG9rZW4gfSA9IGRpcmVjdExpbmU7XG4gIGNvbnN0IHsgdXNlcjogdXNlcklERnJvbVRva2VuIH0gPSBkZWNvZGUodG9rZW4pIHx8IHt9O1xuXG4gIGlmICh1c2VySURGcm9tVG9rZW4pIHtcbiAgICBpZiAodXNlcklERnJvbUFjdGlvbiAmJiB1c2VySURGcm9tQWN0aW9uICE9PSB1c2VySURGcm9tVG9rZW4pIHtcbiAgICAgIGNvbnNvbGUud2FybignV2ViIENoYXQ6IHVzZXIgSUQgaXMgYm90aCBzcGVjaWZpZWQgaW4gdGhlIERpcmVjdCBMaW5lIHRva2VuIGFuZCBwYXNzZWQgaW4sIHdpbGwgdXNlIHRoZSB1c2VyIElEIGZyb20gdGhlIHRva2VuLicpO1xuICAgIH1cblxuICAgIHJldHVybiB1c2VySURGcm9tVG9rZW47XG4gIH0gZWxzZSBpZiAodXNlcklERnJvbUFjdGlvbikge1xuICAgIGlmICh0eXBlb2YgdXNlcklERnJvbUFjdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnNvbGUud2FybignV2ViIENoYXQ6IHVzZXIgSUQgbXVzdCBiZSBhIHN0cmluZy4nKTtcblxuICAgICAgcmV0dXJuIHJhbmRvbVVzZXJJRCgpO1xuICAgIH0gZWxzZSBpZiAoL15kbF8vLnRlc3QodXNlcklERnJvbUFjdGlvbikpIHtcblxuICAgICAgY29uc29sZS53YXJuKCdXZWIgQ2hhdDogdXNlciBJRCBwcmVmaXhlZCB3aXRoIFwiZGxfXCIgaXMgcmVzZXJ2ZWQgYW5kIG11c3QgYmUgZW1iZWRkZWQgaW50byB0aGUgRGlyZWN0IExpbmUgdG9rZW4gdG8gcHJldmVudCBmb3JnZXJ5LicpO1xuXG4gICAgICByZXR1cm4gcmFuZG9tVXNlcklEKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByYW5kb21Vc2VySUQoKTtcbiAgfVxuXG4gIHJldHVybiB1c2VySURGcm9tQWN0aW9uO1xufVxuXG4vLyBXZSBjb3VsZCBtYWtlIHRoaXMgYSBQcm9taXNlIGluc3RlYWQgb2Ygc2FnYSAoZnVuY3Rpb24gZ2VuZXJhdG9yKSB0byBtYWtlIHRoZSBjb2RlIGNsZWFuZXIsIGlmOlxuLy8gMS4gV2UgZm91bmQgYSB3YXkgdG8gY2FuY2VsIFByb21pc2Vcbi8vIDIuIHN1YnNjcmliZSgpIGFyZSBzaGFyZWQgYW1vbmdzdCBhbGwgc3Vic2NyaXB0aW9ucywgZS5nLiB0dXJuIE9ic2VydmFibGUgaW50byBldmVudHNcbmZ1bmN0aW9uKiBjb25uZWN0U2FnYShkaXJlY3RMaW5lKSB7XG4gIC8vIERpcmVjdExpbmVKUyBzdGFydHMgdGhlIGNvbm5lY3Rpb24gb25seSBhZnRlciB0aGUgZmlyc3Qgc3Vic2NyaWJlciBmb3IgYWN0aXZpdHkkLCBub3QgY29ubmVjdGlvblN0YXR1cyRcbiAgY29uc3QgYWN0aXZpdHlTdWJzY3JpcHRpb24gPSBkaXJlY3RMaW5lLmFjdGl2aXR5JC5zdWJzY3JpYmUoeyBuZXh0OiAoKSA9PiAwIH0pO1xuICBjb25zdCB1bnN1YnNjcmliZUFjdGl2aXR5ID0gYWN0aXZpdHlTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUuYmluZChhY3Rpdml0eVN1YnNjcmlwdGlvbik7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCB7IHBheWxvYWQ6IHsgY29ubmVjdGlvblN0YXR1cyB9IH0gPSB5aWVsZCB0YWtlKFVQREFURV9DT05ORUNUSU9OX1NUQVRVUyk7XG5cbiAgICAgIGlmIChjb25uZWN0aW9uU3RhdHVzID09PSBPTkxJTkUpIHtcbiAgICAgICAgLy8gVE9ETzogW1AyXSBEaXJlY3RMaW5lSlMgc2hvdWxkIGtpbGwgdGhlIGNvbm5lY3Rpb24gd2hlbiB3ZSB1bnN1YnNjcmliZVxuICAgICAgICAvLyAgICAgICBCdXQgY3VycmVudGx5IGluIHYzLCBEaXJlY3RMaW5lSlMgZG9lcyBub3QgaGF2ZSB0aGlzIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgLy8gICAgICAgVGh1cywgd2UgbmVlZCB0byBjYWxsIFwiZW5kKClcIiBleHBsaWNpdGx5XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICB1bnN1YnNjcmliZUFjdGl2aXR5KCk7XG4gICAgICAgICAgZGlyZWN0TGluZS5lbmQoKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXR1cyAhPT0gVU5JTklUSUFMSVpFRCAmJiBjb25uZWN0aW9uU3RhdHVzICE9PSBDT05ORUNUSU5HKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbm5lY3QsIERpcmVjdExpbmVKUyByZXR1cm5lZCAkeyBjb25uZWN0aW9uU3RhdHVzIH0uYCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBXZSB3aWxsIHVuc3Vic2NyaWJlIGlmIHdlIGZhaWxlZCB0byBjb25uZWN0IG9yIGdvdCBjYW5jZWxsZWQgb25seS5cbiAgICAvLyBXZSBzaG91bGQgbm90IHVuc3Vic2NyaWJlIGluIGhhcHB5IGNhc2UsIGJlY2F1c2UgRGlyZWN0TGluZUpTIHNob3VsZCByZWx5aW5nIG9uIHRoZSBzdWJzY3JpcHRpb24gdG8gY29ubmVjdC9kaXNjb25uZWN0LlxuICAgIHVuc3Vic2NyaWJlQWN0aXZpdHkoKTtcblxuICAgIHRocm93IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoeWllbGQgY2FuY2VsbGVkKCkpIHtcbiAgICAgIHVuc3Vic2NyaWJlQWN0aXZpdHkoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24qIHJlY29ubmVjdFNhZ2EoKSB7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCB7IHBheWxvYWQ6IHsgY29ubmVjdGlvblN0YXR1cyB9IH0gPSB5aWVsZCB0YWtlKFVQREFURV9DT05ORUNUSU9OX1NUQVRVUyk7XG5cbiAgICBpZiAoY29ubmVjdGlvblN0YXR1cyA9PT0gT05MSU5FKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0dXMgIT09IENPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlY29ubmVjdC4gRGlyZWN0TGluZUpTIHJldHVybmVkICR7IGNvbm5lY3Rpb25TdGF0dXMgfS5gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBpcyBzaW1pbGFyIHRvIGJlaGF2aW9yIG9mIHJlZHV4LXByb21pc2UtbWlkZGxld2FyZSwgYnV0IHVzaW5nIHNhZ2EgaW5zdGVhZCBvZiBQcm9taXNlLlxuLy8gV2UgZ3VhcmFudGVlIFBFTkRJTkcgLT4gRlVMRklMTElORyAtPiBGVUxGSUxMRUQsIG9yIFBFTkRJTkcgLT4gUkVKRUNURUQuIFRoaXMgd2lsbCBoZWxwIHVzIHNpbXBsaWZ5IGxvZ2ljIGluIG90aGVyIHBhcnQgb2YgY29kZS5cbi8vIE5vdGUgdGhhdCBhZnRlciB0aGUgc2FnYSBpcyBjYW5jZWxsZWQsIHN1YnNlcXVlbnQgY2FsbCB0byBwdXQoKSB3aWxsIGJlIGlnbm9yZWQgc2lsZW50bHkuXG5mdW5jdGlvbiogcnVuQXN5bmNFZmZlY3QoeyB0eXBlLCBtZXRhLCBwYXlsb2FkIH0sIGNhbGxFZmZlY3RGYWN0b3J5KSB7XG4gIHRyeSB7XG4gICAgeWllbGQgZm9ya1B1dCh7IHR5cGU6IGAkeyB0eXBlIH1fUEVORElOR2AsIG1ldGEsIHBheWxvYWQgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBjYWxsRWZmZWN0RmFjdG9yeSgpO1xuXG4gICAgeWllbGQgZm9ya1B1dChcbiAgICAgIHsgdHlwZTogYCR7IHR5cGUgfV9GVUxGSUxMSU5HYCwgbWV0YSwgcGF5bG9hZCB9LFxuICAgICAgeyB0eXBlOiBgJHsgdHlwZSB9X0ZVTEZJTExFRGAsIG1ldGEsIHBheWxvYWQgfVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChwYXlsb2FkKSB7XG4gICAgeWllbGQgZm9ya1B1dCh7IHR5cGU6IGAkeyB0eXBlIH1fUkVKRUNURURgLCBlcnJvcjogdHJ1ZSwgbWV0YSwgcGF5bG9hZCB9KTtcblxuICAgIHRocm93IHBheWxvYWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24qIHRha2VEaXNjb25uZWN0QXNFcnJvcigpIHtcbiAgeWllbGQgdGFrZShESVNDT05ORUNUKTtcblxuICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc2Nvbm5lY3RlZCcpO1xufVxuXG5mdW5jdGlvbiBydW5Bc3luY0VmZmVjdFVudGlsRGlzY29ubmVjdChiYXNlQWN0aW9uLCBjYWxsRWZmZWN0RmFjdG9yeSkge1xuICAvLyBXZSBjYW5ub3QgdXNlIHNhZ2EgY2FuY2VsKCkgaGVyZSwgYmVjYXVzZSBjYW5jZWxsaW5nIHNhZ2Egd2lsbCBwcm9oaWJpdCB1cyBmcm9tIHNlbmRpbmcgKl9SRUpFQ1RFRC5cbiAgLy8gV2l0aG91dCBSRUpFQ1RFRCwgaXQgaW1wYWN0cyBvdXIgYXNzdW1wdGlvbnMgYXJvdW5kIFBFTkRJTkcvRlVMRklMTEVEL1JFSkVDVEVELlxuICByZXR1cm4gcnVuQXN5bmNFZmZlY3QoXG4gICAgYmFzZUFjdGlvbixcbiAgICBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHlpZWxkIHJhY2Uoe1xuICAgICAgICBfOiB0YWtlRGlzY29ubmVjdEFzRXJyb3IoKSxcbiAgICAgICAgcmVzdWx0OiBjYWxsRWZmZWN0RmFjdG9yeSgpXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKiAoKSB7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGRpcmVjdExpbmUsXG4gICAgICAgIHVzZXJJRDogdXNlcklERnJvbUFjdGlvbixcbiAgICAgICAgdXNlcm5hbWVcbiAgICAgIH1cbiAgICB9ID0geWllbGQgdGFrZShDT05ORUNUKTtcblxuICAgIGNvbnN0IHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXNUYXNrID0geWllbGQgZm9yayhvYnNlcnZlQW5kUHV0Q29ubmVjdGlvblN0YXR1c1VwZGF0ZSwgZGlyZWN0TGluZSk7XG4gICAgbGV0IGRpc2Nvbm5lY3RNZXRhO1xuXG4gICAgLy8gVE9ETzogW1AyXSBDaGVja3MgaWYgdGhpcyBhdHRhY2hlZCBzdWJ0YXNrIHdpbGwgZ2V0IGtpbGxlZCBpZiB0aGUgcGFyZW50IHRhc2sgaXMgY29tcGxldGUgKHBlYWNlZnVsbHkpLCBlcnJvcmVkIG91dCwgb3IgY2FuY2VsbGVkLlxuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICB1c2VySUQ6IHJlY3RpZnlVc2VySUQoZGlyZWN0TGluZSwgdXNlcklERnJvbUFjdGlvbiksXG4gICAgICB1c2VybmFtZVxuICAgIH07XG5cbiAgICAvLyBXZSB3aWxsIGRpc3BhdGNoIENPTk5FQ1RfUEVORElORywgd2FpdCBmb3IgY29ubmVjdCBjb21wbGV0ZWQsIGVycm9yZWQsIG9yIGNhbmNlbGxlZCAodGhydSBkaXNjb25uZWN0KS5cbiAgICAvLyBUaGVuIGRpc3BhdGNoIENPTk5FQ1RfRlVMRklMTEVEL0NPTk5FQ1RfUkVKRUNURUQgYXMgbmVlZGVkLlxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmREaXJlY3RMaW5lID0geWllbGQgcnVuQXN5bmNFZmZlY3RVbnRpbERpc2Nvbm5lY3QoXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBDT05ORUNULFxuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgcGF5bG9hZDogeyBkaXJlY3RMaW5lIH1cbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gY2FsbChjb25uZWN0U2FnYSwgZGlyZWN0TGluZSlcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAvLyBXZSBhcmUgd2FpdGluZyBmb3IgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlIG9yIGRpc2Nvbm5lY3QgYWN0aW9uLlxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXNBY3Rpb246IHtcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyBjb25uZWN0aW9uU3RhdHVzIH0gPSB7fVxuICAgICAgICAgICAgfSA9IHt9XG4gICAgICAgICAgfSA9IHlpZWxkIHJhY2Uoe1xuICAgICAgICAgICAgXzogdGFrZShESVNDT05ORUNUKSxcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXNBY3Rpb246IHRha2UoVVBEQVRFX0NPTk5FQ1RJT05fU1RBVFVTKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gSWYgaXQgaXMgbm90IGRpc2Nvbm5lY3QgYWN0aW9uLCBjb25uZWN0aW9uU3RhdHVzIHdpbGwgbm90IGJlIHVuZGVmaW5lZC5cbiAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXR1cyA9PT0gQ09OTkVDVElORykge1xuICAgICAgICAgICAgLy8gSWYgRGlyZWN0TGluZUpTIGNoYW5nZWQgY29ubmVjdGlvblN0YXR1cyB0byBDT05ORUNUSU5HLCB3ZSB3aWxsIHRyZWF0IGl0IGFzIHJlY29ubmVjdCBzdGF0dXMuXG4gICAgICAgICAgICB5aWVsZCBydW5Bc3luY0VmZmVjdFVudGlsRGlzY29ubmVjdChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFJFQ09OTkVDVCxcbiAgICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgZGlyZWN0TGluZSB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICgpID0+IGNhbGwocmVjb25uZWN0U2FnYSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdHVzICE9PSBPTkxJTkUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29ubmVjdGlvblN0YXR1cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBraWxsIHRoZSBjb25uZWN0aW9uIGJlY2F1c2UgRGlyZWN0TGluZUpTIHdhbnQgdG8gY2xvc2UgaXQuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlZCB0byAkeyBjb25uZWN0aW9uU3RhdHVzIH1gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFNvbWVvbmUgZGlzcGF0Y2hlZCBkaXNjb25uZWN0IGFjdGlvbi5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBlbmREaXJlY3RMaW5lKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRpc2Nvbm5lY3RNZXRhID0geyBlcnJvciB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB5aWVsZCBjYW5jZWwodXBkYXRlQ29ubmVjdGlvblN0YXR1c1Rhc2spO1xuXG4gICAgICAvLyBFdmVuIGlmIHRoZSBjb25uZWN0aW9uIGlzIGludGVycnVwdGVkLCB3ZSB3aWxsIHN0aWxsIGVtaXQgRElTQ09OTkVDVF9QRU5ESU5HLlxuICAgICAgLy8gVGhpcyB3aWxsIG1ha2VzIGhhbmRsaW5nIGxvZ2ljIGVhc2llci4gSWYgQ09OTkVDVF9GVUxGSUxMRUQsIHdlIGd1YXJhbnRlZSBESVNDT05ORUNUX1BFTkRJTkcuXG4gICAgICB5aWVsZCBmb3JrUHV0KFxuICAgICAgICB7IHR5cGU6IERJU0NPTk5FQ1RfUEVORElORywgbWV0YTogZGlzY29ubmVjdE1ldGEsIHBheWxvYWQ6IHsgZGlyZWN0TGluZSB9IH0sXG4gICAgICAgIHsgdHlwZTogRElTQ09OTkVDVF9GVUxGSUxMRUQsIG1ldGE6IGRpc2Nvbm5lY3RNZXRhLCBwYXlsb2FkOiB7IGRpcmVjdExpbmUgfSB9XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIl19