'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _memoizeOne = require('memoize-one');

var _memoizeOne2 = _interopRequireDefault(_memoizeOne);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Context = require('./Context');

var _Context2 = _interopRequireDefault(_Context);

var _prefix = require('./prefix');

var _prefix2 = _interopRequireDefault(_prefix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function chainListener() {
  for (var _len = arguments.length, listeners = Array(_len), _key = 0; _key < _len; _key++) {
    listeners[_key] = arguments[_key];
  }

  return function () {
    var _this = this,
        _arguments = arguments;

    listeners.forEach(function (listener) {
      return listener.apply(_this, _arguments);
    });
  };
}

var Composer = function (_React$Component) {
  _inherits(Composer, _React$Component);

  function Composer(props) {
    _classCallCheck(this, Composer);

    var _this2 = _possibleConstructorReturn(this, (Composer.__proto__ || Object.getPrototypeOf(Composer)).call(this, props));

    _this2.createGrammarList = (0, _memoizeOne2.default)(function (speechGrammarList, grammar) {
      var grammarList = new speechGrammarList();

      grammar && grammarList.addFromString(grammar, 1);

      return grammarList;
    });

    _this2.createRecognition = (0, _memoizeOne2.default)(function (speechRecognition) {
      return speechRecognition && new speechRecognition();
    });

    _this2.handleAudioEnd = _this2.handleAudioEnd.bind(_this2);
    _this2.handleAudioStart = _this2.handleAudioStart.bind(_this2);
    _this2.handleEnd = _this2.handleEnd.bind(_this2);
    _this2.handleError = _this2.handleError.bind(_this2);
    _this2.handleRawEvent = _this2.handleRawEvent.bind(_this2);
    _this2.handleResult = _this2.handleResult.bind(_this2);
    _this2.handleStart = _this2.handleStart.bind(_this2);

    _this2.state = {
      readyState: 0,
      supported: !!props.speechRecognition
    };
    return _this2;
  }

  _createClass(Composer, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var recognition = this.recognition;

      var nextState = void 0;

      if (nextProps.speechRecognition !== this.props.speechRecognition) {
        recognition && recognition.abort();
        recognition = this.recognition = null;

        nextState = _extends({}, nextState, { supported: !!nextProps.speechRecognition });
      }

      if (nextProps.started !== this.props.started) {
        if (nextProps.started) {
          this.start(nextProps);
        } else {
          recognition && recognition.abort();
        }
      }

      nextState && this.setState(function () {
        return nextState;
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.recognition && this.recognition.abort();
    }
  }, {
    key: 'handleAudioEnd',
    value: function handleAudioEnd() {
      this.setState(function () {
        return { readyState: 3 };
      });
    }
  }, {
    key: 'handleAudioStart',
    value: function handleAudioStart() {
      this.setState(function () {
        return { readyState: 2 };
      });

      // Web Speech API does not emit "result" when nothing is heard, and Chrome does not emit "nomatch" event.
      // Because we emitted onProgress, we should emit "dictate" if not error, so they works in pair.
      this.emitDictateOnEnd = true;
      this.props.onProgress && this.props.onProgress({});
    }
  }, {
    key: 'handleEnd',
    value: function handleEnd() {
      if (this.emitDictateOnEnd) {
        this.props.onDictate && this.props.onDictate({});
      }

      this.setState(function () {
        return { readyState: 0 };
      });
    }
  }, {
    key: 'handleError',
    value: function handleError(event) {
      this.setState(function () {
        return _extends({
          readyState: 0
        }, event.error === 'not-allowed' && { supported: false });
      });

      // Error out, no need to emit "dictate"
      this.emitDictateOnEnd = false;
      this.props.onError && this.props.onError(event);
    }
  }, {
    key: 'handleRawEvent',
    value: function handleRawEvent(event) {
      this.props.onRawEvent && this.props.onRawEvent(event);
    }
  }, {
    key: 'handleResult',
    value: function handleResult(event) {
      var props = this.props;
      var rawResults = event.results;


      if (rawResults.length) {
        var results = [].map.call(rawResults, function (_ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              firstAlt = _ref2[0];

          return {
            confidence: firstAlt.confidence,
            transcript: firstAlt.transcript
          };
        });

        var _rawResults = _slicedToArray(rawResults, 1),
            first = _rawResults[0];

        if (first.isFinal) {
          this.emitDictateOnEnd = false;
          props.onDictate && props.onDictate({ result: results[0] });
        } else {
          props.onProgress && props.onProgress({ results: results });
        }
      }
    }
  }, {
    key: 'handleStart',
    value: function handleStart() {
      this.setState(function () {
        return { readyState: 1 };
      });
    }
  }, {
    key: 'start',
    value: function start(props) {
      this.recognition && this.recognition.abort();

      if (!this.state.supported) {
        throw new Error('Speech recognition is not supported');
      }

      var recognition = this.recognition = this.createRecognition(props.speechRecognition);

      recognition.grammars = this.createGrammarList(props.speechGrammarList, props.grammar);
      recognition.lang = props.lang;
      recognition.interimResults = true;
      recognition.onaudioend = chainListener(this.handleAudioEnd, this.handleRawEvent);
      recognition.onaudiostart = chainListener(this.handleAudioStart, this.handleRawEvent);
      recognition.onend = chainListener(this.handleEnd, this.handleRawEvent);
      recognition.onerror = chainListener(this.handleError, this.handleRawEvent);
      recognition.onnomatch = this.handleRawEvent;
      recognition.onresult = chainListener(this.handleResult, this.handleRawEvent);
      recognition.onsoundend = this.handleRawEvent;
      recognition.onsoundstart = this.handleRawEvent;
      recognition.onspeechend = this.handleRawEvent;
      recognition.onspeechstart = this.handleRawEvent;
      recognition.onstart = chainListener(this.handleStart, this.handleRawEvent);

      props.extra && Object.keys(props.extra).forEach(function (key) {
        recognition[key] = props.extra[key];
      });

      recognition.start();
    }
  }, {
    key: 'render',
    value: function render() {
      var props = this.props,
          state = this.state;
      var children = props.children;


      return _react2.default.createElement(
        _Context2.default.Provider,
        { value: state },
        _react2.default.createElement(
          _Context2.default.Consumer,
          null,
          function (context) {
            return typeof children === 'function' ? children(context) : children;
          }
        )
      );
    }
  }]);

  return Composer;
}(_react2.default.Component);

exports.default = Composer;


Composer.defaultProps = {
  speechGrammarList: (0, _prefix2.default)('SpeechGrammarList'),
  speechRecognition: (0, _prefix2.default)('SpeechRecognition')
};

Composer.propTypes = {
  extra: _propTypes2.default.any,
  lang: _propTypes2.default.string,
  onDictate: _propTypes2.default.func,
  onError: _propTypes2.default.func,
  onProgress: _propTypes2.default.func,
  onRawEvent: _propTypes2.default.func,
  speechGrammarList: _propTypes2.default.any,
  speechRecognition: _propTypes2.default.any
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Db21wb3Nlci5qcyJdLCJuYW1lcyI6WyJjaGFpbkxpc3RlbmVyIiwibGlzdGVuZXJzIiwiZm9yRWFjaCIsImxpc3RlbmVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJDb21wb3NlciIsInByb3BzIiwiY3JlYXRlR3JhbW1hckxpc3QiLCJzcGVlY2hHcmFtbWFyTGlzdCIsImdyYW1tYXIiLCJncmFtbWFyTGlzdCIsImFkZEZyb21TdHJpbmciLCJjcmVhdGVSZWNvZ25pdGlvbiIsInNwZWVjaFJlY29nbml0aW9uIiwiaGFuZGxlQXVkaW9FbmQiLCJiaW5kIiwiaGFuZGxlQXVkaW9TdGFydCIsImhhbmRsZUVuZCIsImhhbmRsZUVycm9yIiwiaGFuZGxlUmF3RXZlbnQiLCJoYW5kbGVSZXN1bHQiLCJoYW5kbGVTdGFydCIsInN0YXRlIiwicmVhZHlTdGF0ZSIsInN1cHBvcnRlZCIsIm5leHRQcm9wcyIsInJlY29nbml0aW9uIiwibmV4dFN0YXRlIiwiYWJvcnQiLCJzdGFydGVkIiwic3RhcnQiLCJzZXRTdGF0ZSIsImVtaXREaWN0YXRlT25FbmQiLCJvblByb2dyZXNzIiwib25EaWN0YXRlIiwiZXZlbnQiLCJlcnJvciIsIm9uRXJyb3IiLCJvblJhd0V2ZW50IiwicmF3UmVzdWx0cyIsInJlc3VsdHMiLCJsZW5ndGgiLCJtYXAiLCJjYWxsIiwiZmlyc3RBbHQiLCJjb25maWRlbmNlIiwidHJhbnNjcmlwdCIsImZpcnN0IiwiaXNGaW5hbCIsInJlc3VsdCIsIkVycm9yIiwiZ3JhbW1hcnMiLCJsYW5nIiwiaW50ZXJpbVJlc3VsdHMiLCJvbmF1ZGlvZW5kIiwib25hdWRpb3N0YXJ0Iiwib25lbmQiLCJvbmVycm9yIiwib25ub21hdGNoIiwib25yZXN1bHQiLCJvbnNvdW5kZW5kIiwib25zb3VuZHN0YXJ0Iiwib25zcGVlY2hlbmQiLCJvbnNwZWVjaHN0YXJ0Iiwib25zdGFydCIsImV4dHJhIiwiT2JqZWN0Iiwia2V5cyIsImtleSIsImNoaWxkcmVuIiwiY29udGV4dCIsIlJlYWN0IiwiQ29tcG9uZW50IiwiZGVmYXVsdFByb3BzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiYW55Iiwic3RyaW5nIiwiZnVuYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUEsU0FBU0EsYUFBVCxHQUFxQztBQUFBLG9DQUFYQyxTQUFXO0FBQVhBLGFBQVc7QUFBQTs7QUFDbkMsU0FBTyxZQUFZO0FBQUE7QUFBQTs7QUFDakJBLGNBQVVDLE9BQVYsQ0FBa0I7QUFBQSxhQUFZQyxTQUFTQyxLQUFULENBQWUsS0FBZixFQUFxQkMsVUFBckIsQ0FBWjtBQUFBLEtBQWxCO0FBQ0QsR0FGRDtBQUdEOztJQUVvQkMsUTs7O0FBQ25CLG9CQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEscUhBQ1hBLEtBRFc7O0FBR2pCLFdBQUtDLGlCQUFMLEdBQXlCLDBCQUFRLFVBQUNDLGlCQUFELEVBQW9CQyxPQUFwQixFQUFnQztBQUMvRCxVQUFNQyxjQUFjLElBQUlGLGlCQUFKLEVBQXBCOztBQUVBQyxpQkFBV0MsWUFBWUMsYUFBWixDQUEwQkYsT0FBMUIsRUFBbUMsQ0FBbkMsQ0FBWDs7QUFFQSxhQUFPQyxXQUFQO0FBQ0QsS0FOd0IsQ0FBekI7O0FBUUEsV0FBS0UsaUJBQUwsR0FBeUIsMEJBQVE7QUFBQSxhQUFxQkMscUJBQXFCLElBQUlBLGlCQUFKLEVBQTFDO0FBQUEsS0FBUixDQUF6Qjs7QUFFQSxXQUFLQyxjQUFMLEdBQXNCLE9BQUtBLGNBQUwsQ0FBb0JDLElBQXBCLFFBQXRCO0FBQ0EsV0FBS0MsZ0JBQUwsR0FBd0IsT0FBS0EsZ0JBQUwsQ0FBc0JELElBQXRCLFFBQXhCO0FBQ0EsV0FBS0UsU0FBTCxHQUFpQixPQUFLQSxTQUFMLENBQWVGLElBQWYsUUFBakI7QUFDQSxXQUFLRyxXQUFMLEdBQW1CLE9BQUtBLFdBQUwsQ0FBaUJILElBQWpCLFFBQW5CO0FBQ0EsV0FBS0ksY0FBTCxH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S0FBMUI7QUFDRTtBQUFDLDJCQUFELENBQVMsUUFBVDtBQUFBO0FBQ0k7QUFBQSxtQkFBVyxPQUFPK0MsUUFBUCxLQUFvQixVQUFwQixHQUFpQ0EsU0FBU0MsT0FBVCxDQUFqQyxHQUFxREQsUUFBaEU7QUFBQTtBQURKO0FBREYsT0FERjtBQU9EOzs7O0VBN0ptQ0UsZ0JBQU1DLFM7O2tCQUF2Qm5FLFE7OztBQWdLckJBLFNBQVNvRSxZQUFULEdBQXdCO0FBQ3RCakUscUJBQW1CLHNCQUFPLG1CQUFQLENBREc7QUFFdEJLLHFCQUFtQixzQkFBTyxtQkFBUDtBQUZHLENBQXhCOztBQUtBUixTQUFTcUUsU0FBVCxHQUFxQjtBQUNuQlQsU0FBT1Usb0JBQVVDLEdBREU7QUFFbkJ4QixRQUFNdUIsb0JBQVVFLE1BRkc7QUFHbkIzQyxhQUFXeUMsb0JBQVVHLElBSEY7QUFJbkJ6QyxXQUFTc0Msb0JBQVVHLElBSkE7QUFLbkI3QyxjQUFZMEMsb0JBQVVHLElBTEg7QUFNbkJ4QyxjQUFZcUMsb0JBQVVHLElBTkg7QUFPbkJ0RSxxQkFBbUJtRSxvQkFBVUMsR0FQVjtBQVFuQi9ELHFCQUFtQjhELG9CQUFVQztBQVJWLENBQXJCIiwiZmlsZSI6IkNvbXBvc2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1lbW9pemUgZnJvbSAnbWVtb2l6ZS1vbmUnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBDb250ZXh0IGZyb20gJy4vQ29udGV4dCc7XG5pbXBvcnQgcHJlZml4IGZyb20gJy4vcHJlZml4JztcblxuZnVuY3Rpb24gY2hhaW5MaXN0ZW5lciguLi5saXN0ZW5lcnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb3NlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5jcmVhdGVHcmFtbWFyTGlzdCA9IG1lbW9pemUoKHNwZWVjaEdyYW1tYXJMaXN0LCBncmFtbWFyKSA9PiB7XG4gICAgICBjb25zdCBncmFtbWFyTGlzdCA9IG5ldyBzcGVlY2hHcmFtbWFyTGlzdCgpO1xuXG4gICAgICBncmFtbWFyICYmIGdyYW1tYXJMaXN0LmFkZEZyb21TdHJpbmcoZ3JhbW1hciwgMSk7XG5cbiAgICAgIHJldHVybiBncmFtbWFyTGlzdDtcbiAgICB9KTtcblxuICAgIHRoaXMuY3JlYXRlUmVjb2duaXRpb24gPSBtZW1vaXplKHNwZWVjaFJlY29nbml0aW9uID0+IHNwZWVjaFJlY29nbml0aW9uICYmIG5ldyBzcGVlY2hSZWNvZ25pdGlvbigpKTtcblxuICAgIHRoaXMuaGFuZGxlQXVkaW9FbmQgPSB0aGlzLmhhbmRsZUF1ZGlvRW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVBdWRpb1N0YXJ0ID0gdGhpcy5oYW5kbGVBdWRpb1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVFbmQgPSB0aGlzLmhhbmRsZUVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlRXJyb3IgPSB0aGlzLmhhbmRsZUVycm9yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVSYXdFdmVudCA9IHRoaXMuaGFuZGxlUmF3RXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZVJlc3VsdCA9IHRoaXMuaGFuZGxlUmVzdWx0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVTdGFydCA9IHRoaXMuaGFuZGxlU3RhcnQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICByZWFkeVN0YXRlOiAwLFxuICAgICAgc3VwcG9ydGVkOiAhIXByb3BzLnNwZWVjaFJlY29nbml0aW9uXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgbGV0IHsgcmVjb2duaXRpb24gfSA9IHRoaXM7XG4gICAgbGV0IG5leHRTdGF0ZTtcblxuICAgIGlmIChuZXh0UHJvcHMuc3BlZWNoUmVjb2duaXRpb24gIT09IHRoaXMucHJvcHMuc3BlZWNoUmVjb2duaXRpb24pIHtcbiAgICAgIHJlY29nbml0aW9uICYmIHJlY29nbml0aW9uLmFib3J0KCk7XG4gICAgICByZWNvZ25pdGlvbiA9IHRoaXMucmVjb2duaXRpb24gPSBudWxsO1xuXG4gICAgICBuZXh0U3RhdGUgPSB7IC4uLm5leHRTdGF0ZSwgc3VwcG9ydGVkOiAhIW5leHRQcm9wcy5zcGVlY2hSZWNvZ25pdGlvbiB9O1xuICAgIH1cblxuICAgIGlmIChuZXh0UHJvcHMuc3RhcnRlZCAhPT0gdGhpcy5wcm9wcy5zdGFydGVkKSB7XG4gICAgICBpZiAobmV4dFByb3BzLnN0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5zdGFydChuZXh0UHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjb2duaXRpb24gJiYgcmVjb2duaXRpb24uYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0U3RhdGUgJiYgdGhpcy5zZXRTdGF0ZSgoKSA9PiBuZXh0U3RhdGUpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5yZWNvZ25pdGlvbiAmJiB0aGlzLnJlY29nbml0aW9uLmFib3J0KCk7XG4gIH1cblxuICBoYW5kbGVBdWRpb0VuZCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IHJlYWR5U3RhdGU6IDMgfSkpO1xuICB9XG5cbiAgaGFuZGxlQXVkaW9TdGFydCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IHJlYWR5U3RhdGU6IDIgfSkpO1xuXG4gICAgLy8gV2ViIFNwZWVjaCBBUEkgZG9lcyBub3QgZW1pdCBcInJlc3VsdFwiIHdoZW4gbm90aGluZyBpcyBoZWFyZCwgYW5kIENocm9tZSBkb2VzIG5vdCBlbWl0IFwibm9tYXRjaFwiIGV2ZW50LlxuICAgIC8vIEJlY2F1c2Ugd2UgZW1pdHRlZCBvblByb2dyZXNzLCB3ZSBzaG91bGQgZW1pdCBcImRpY3RhdGVcIiBpZiBub3QgZXJyb3IsIHNvIHRoZXkgd29ya3MgaW4gcGFpci5cbiAgICB0aGlzLmVtaXREaWN0YXRlT25FbmQgPSB0cnVlO1xuICAgIHRoaXMucHJvcHMub25Qcm9ncmVzcyAmJiB0aGlzLnByb3BzLm9uUHJvZ3Jlc3Moe30pO1xuICB9XG5cbiAgaGFuZGxlRW5kKCkge1xuICAgIGlmICh0aGlzLmVtaXREaWN0YXRlT25FbmQpIHtcbiAgICAgIHRoaXMucHJvcHMub25EaWN0YXRlICYmIHRoaXMucHJvcHMub25EaWN0YXRlKHt9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IHJlYWR5U3RhdGU6IDAgfSkpO1xuICB9XG5cbiAgaGFuZGxlRXJyb3IoZXZlbnQpIHtcbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7XG4gICAgICByZWFkeVN0YXRlOiAwLFxuICAgICAgLi4uKGV2ZW50LmVycm9yID09PSAnbm90LWFsbG93ZWQnICYmIHsgc3VwcG9ydGVkOiBmYWxzZSB9KVxuICAgIH0pKTtcblxuICAgIC8vIEVycm9yIG91dCwgbm8gbmVlZCB0byBlbWl0IFwiZGljdGF0ZVwiXG4gICAgdGhpcy5lbWl0RGljdGF0ZU9uRW5kID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wcy5vbkVycm9yICYmIHRoaXMucHJvcHMub25FcnJvcihldmVudCk7XG4gIH1cblxuICBoYW5kbGVSYXdFdmVudChldmVudCkge1xuICAgIHRoaXMucHJvcHMub25SYXdFdmVudCAmJiB0aGlzLnByb3BzLm9uUmF3RXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgaGFuZGxlUmVzdWx0KGV2ZW50KSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJlc3VsdHM6IHJhd1Jlc3VsdHMgfSA9IGV2ZW50O1xuXG4gICAgaWYgKHJhd1Jlc3VsdHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCByZXN1bHRzID0gW10ubWFwLmNhbGwocmF3UmVzdWx0cywgKFtmaXJzdEFsdF0pID0+ICh7XG4gICAgICAgIGNvbmZpZGVuY2U6IGZpcnN0QWx0LmNvbmZpZGVuY2UsXG4gICAgICAgIHRyYW5zY3JpcHQ6IGZpcnN0QWx0LnRyYW5zY3JpcHRcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3QgW2ZpcnN0XSA9IHJhd1Jlc3VsdHM7XG5cbiAgICAgIGlmIChmaXJzdC5pc0ZpbmFsKSB7XG4gICAgICAgIHRoaXMuZW1pdERpY3RhdGVPbkVuZCA9IGZhbHNlO1xuICAgICAgICBwcm9wcy5vbkRpY3RhdGUgJiYgcHJvcHMub25EaWN0YXRlKHsgcmVzdWx0OiByZXN1bHRzWzBdIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMub25Qcm9ncmVzcyAmJiBwcm9wcy5vblByb2dyZXNzKHsgcmVzdWx0cyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVTdGFydCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IHJlYWR5U3RhdGU6IDEgfSkpO1xuICB9XG5cbiAgc3RhcnQocHJvcHMpIHtcbiAgICB0aGlzLnJlY29nbml0aW9uICYmIHRoaXMucmVjb2duaXRpb24uYWJvcnQoKTtcblxuICAgIGlmICghdGhpcy5zdGF0ZS5zdXBwb3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3BlZWNoIHJlY29nbml0aW9uIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWNvZ25pdGlvbiA9IHRoaXMucmVjb2duaXRpb24gPSB0aGlzLmNyZWF0ZVJlY29nbml0aW9uKHByb3BzLnNwZWVjaFJlY29nbml0aW9uKTtcblxuICAgIHJlY29nbml0aW9uLmdyYW1tYXJzID0gdGhpcy5jcmVhdGVHcmFtbWFyTGlzdChwcm9wcy5zcGVlY2hHcmFtbWFyTGlzdCwgcHJvcHMuZ3JhbW1hcik7XG4gICAgcmVjb2duaXRpb24ubGFuZyA9IHByb3BzLmxhbmc7XG4gICAgcmVjb2duaXRpb24uaW50ZXJpbVJlc3VsdHMgPSB0cnVlO1xuICAgIHJlY29nbml0aW9uLm9uYXVkaW9lbmQgPSBjaGFpbkxpc3RlbmVyKHRoaXMuaGFuZGxlQXVkaW9FbmQsIHRoaXMuaGFuZGxlUmF3RXZlbnQpO1xuICAgIHJlY29nbml0aW9uLm9uYXVkaW9zdGFydCA9IGNoYWluTGlzdGVuZXIodGhpcy5oYW5kbGVBdWRpb1N0YXJ0LCB0aGlzLmhhbmRsZVJhd0V2ZW50KTtcbiAgICByZWNvZ25pdGlvbi5vbmVuZCA9IGNoYWluTGlzdGVuZXIodGhpcy5oYW5kbGVFbmQsIHRoaXMuaGFuZGxlUmF3RXZlbnQpO1xuICAgIHJlY29nbml0aW9uLm9uZXJyb3IgPSBjaGFpbkxpc3RlbmVyKHRoaXMuaGFuZGxlRXJyb3IsIHRoaXMuaGFuZGxlUmF3RXZlbnQpO1xuICAgIHJlY29nbml0aW9uLm9ubm9tYXRjaCA9IHRoaXMuaGFuZGxlUmF3RXZlbnQ7XG4gICAgcmVjb2duaXRpb24ub25yZXN1bHQgPSBjaGFpbkxpc3RlbmVyKHRoaXMuaGFuZGxlUmVzdWx0LCB0aGlzLmhhbmRsZVJhd0V2ZW50KTtcbiAgICByZWNvZ25pdGlvbi5vbnNvdW5kZW5kID0gdGhpcy5oYW5kbGVSYXdFdmVudDtcbiAgICByZWNvZ25pdGlvbi5vbnNvdW5kc3RhcnQgPSB0aGlzLmhhbmRsZVJhd0V2ZW50O1xuICAgIHJlY29nbml0aW9uLm9uc3BlZWNoZW5kID0gdGhpcy5oYW5kbGVSYXdFdmVudDtcbiAgICByZWNvZ25pdGlvbi5vbnNwZWVjaHN0YXJ0ID0gdGhpcy5oYW5kbGVSYXdFdmVudDtcbiAgICByZWNvZ25pdGlvbi5vbnN0YXJ0ID0gY2hhaW5MaXN0ZW5lcih0aGlzLmhhbmRsZVN0YXJ0LCB0aGlzLmhhbmRsZVJhd0V2ZW50KTtcblxuICAgIHByb3BzLmV4dHJhICYmIE9iamVjdC5rZXlzKHByb3BzLmV4dHJhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICByZWNvZ25pdGlvbltrZXldID0gcHJvcHMuZXh0cmFba2V5XTtcbiAgICB9KTtcblxuICAgIHJlY29nbml0aW9uLnN0YXJ0KCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPENvbnRleHQuUHJvdmlkZXIgdmFsdWU9eyBzdGF0ZSB9PlxuICAgICAgICA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICB7IGNvbnRleHQgPT4gdHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID8gY2hpbGRyZW4oY29udGV4dCkgOiBjaGlsZHJlbiB9XG4gICAgICAgIDwvQ29udGV4dC5Db25zdW1lcj5cbiAgICAgIDwvQ29udGV4dC5Qcm92aWRlcj5cbiAgICApO1xuICB9XG59XG5cbkNvbXBvc2VyLmRlZmF1bHRQcm9wcyA9IHtcbiAgc3BlZWNoR3JhbW1hckxpc3Q6IHByZWZpeCgnU3BlZWNoR3JhbW1hckxpc3QnKSxcbiAgc3BlZWNoUmVjb2duaXRpb246IHByZWZpeCgnU3BlZWNoUmVjb2duaXRpb24nKVxufTtcblxuQ29tcG9zZXIucHJvcFR5cGVzID0ge1xuICBleHRyYTogUHJvcFR5cGVzLmFueSxcbiAgbGFuZzogUHJvcFR5cGVzLnN0cmluZyxcbiAgb25EaWN0YXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25FcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uUHJvZ3Jlc3M6IFByb3BUeXBlcy5mdW5jLFxuICBvblJhd0V2ZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgc3BlZWNoR3JhbW1hckxpc3Q6IFByb3BUeXBlcy5hbnksXG4gIHNwZWVjaFJlY29nbml0aW9uOiBQcm9wVHlwZXMuYW55XG59O1xuIl19