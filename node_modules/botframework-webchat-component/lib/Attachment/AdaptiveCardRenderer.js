"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _Localize = require("../Localization/Localize");

var _connectToWebChat = _interopRequireDefault(require("../connectToWebChat"));

var _ErrorBox = _interopRequireDefault(require("../ErrorBox"));

var _getTabIndex = _interopRequireDefault(require("../Utils/TypeFocusSink/getTabIndex"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var AdaptiveCardRenderer =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(AdaptiveCardRenderer, _React$PureComponent);

  function AdaptiveCardRenderer(props) {
    var _this;

    _classCallCheck(this, AdaptiveCardRenderer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AdaptiveCardRenderer).call(this, props));
    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));
    _this.handleExecuteAction = _this.handleExecuteAction.bind(_assertThisInitialized(_this));
    _this.contentRef = _react.default.createRef();
    _this.state = {
      error: null
    };
    return _this;
  }

  _createClass(AdaptiveCardRenderer, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.renderCard();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.adaptiveCard !== this.props.adaptiveCard) {
        this.renderCard();
      }
    }
  }, {
    key: "handleClick",
    value: function handleClick(_ref) {
      var target = _ref.target;

      // Some items, e.g. tappable text, cannot be disabled thru DOM attributes
      if (this.props.disabled) {
        return;
      }

      var tabIndex = (0, _getTabIndex.default)(target); // If the user is clicking on something that is already clickable, do not allow them to click the card.
      // E.g. a hero card can be tappable, and image and buttons inside the hero card can also be tappable.

      if (typeof tabIndex !== 'number' || tabIndex < 0) {
        var _this$props = this.props,
            onCardAction = _this$props.onCardAction,
            tapAction = _this$props.tapAction;
        tapAction && onCardAction(tapAction);
      }
    }
  }, {
    key: "handleExecuteAction",
    value: function handleExecuteAction(action) {
      var props = this.props; // Some items, e.g. tappable image, cannot be disabled thru DOM attributes

      if (props.disabled) {
        return;
      }

      var actionTypeName = action.getJsonTypeName();

      if (actionTypeName === 'Action.OpenUrl') {
        props.onCardAction({
          type: 'openUrl',
          value: action.url
        });
      } else if (actionTypeName === 'Action.Submit') {
        if (typeof action.data !== 'undefined') {
          var actionData = action.data;

          if (actionData && actionData.__isBotFrameworkCardAction) {
            var cardAction = actionData.cardAction;
            var displayText = cardAction.displayText,
                type = cardAction.type,
                value = cardAction.value;
            props.onCardAction({
              displayText: displayText,
              type: type,
              value: value
            });
          } else {
            props.onCardAction({
              type: typeof action.data === 'string' ? 'imBack' : 'postBack',
              value: action.data
            });
          }
        }
      } else {
        console.error("Web Chat: received unknown action from Adaptive Cards");
        console.error(action);
      }
    }
  }, {
    key: "renderCard",
    value: function renderCard() {
      var current = this.contentRef.current;
      var _this$props2 = this.props,
          adaptiveCard = _this$props2.adaptiveCard,
          adaptiveCardHostConfig = _this$props2.adaptiveCardHostConfig,
          renderMarkdown = _this$props2.renderMarkdown;

      if (current && adaptiveCard) {
        // Currently, the only way to set the Markdown engine is to set it thru static member of AdaptiveCard class
        // TODO: [P3] Checks if we could make the "renderMarkdown" per card
        //       This could be limitations from Adaptive Cards package
        //       Because there could be timing difference between .parse and .render, we could be using wrong Markdown engine
        adaptiveCard.constructor.onProcessMarkdown = function (text, result) {
          if (renderMarkdown) {
            result.outputHtml = renderMarkdown(text);
            result.didProcess = true;
          }
        };

        adaptiveCard.hostConfig = adaptiveCardHostConfig;
        adaptiveCard.onExecuteAction = this.handleExecuteAction;
        var errors = adaptiveCard.validate();

        if (errors.length) {
          return this.setState(function () {
            return {
              error: errors
            };
          });
        }

        var element;

        try {
          element = adaptiveCard.render();
        } catch (err) {
          return this.setState(function () {
            return {
              errors: err
            };
          });
        }

        if (!element) {
          return this.setState(function () {
            return {
              error: 'Adaptive Card rendered as empty element'
            };
          });
        }

        if (this.state.error) {
          this.setState(function () {
            return {
              error: null
            };
          });
        }

        if (this.props.disabled) {
          var hyperlinks = element.querySelectorAll('a');
          var inputs = element.querySelectorAll('button, input, select, textarea');
          [].forEach.call(inputs, function (input) {
            input.disabled = true;
          });
          [].forEach.call(hyperlinks, function (hyperlink) {
            hyperlink.addEventListener('click', function (event) {
              event.preventDefault();
              event.stopImmediatePropagation();
              event.stopPropagation();
            });
          });
        }

        var firstChild = current.children[0];

        if (firstChild) {
          current.replaceChild(element, firstChild);
        } else {
          current.appendChild(element);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          language = _this$props3.language,
          styleSet = _this$props3.styleSet,
          error = this.state.error;
      return error ? _react.default.createElement(_ErrorBox.default, {
        message: (0, _Localize.localize)('Adaptive Card render error', language)
      }, _react.default.createElement("pre", null, JSON.stringify(error, null, 2))) : _react.default.createElement("div", {
        className: styleSet.adaptiveCardRenderer,
        onClick: this.handleClick,
        ref: this.contentRef
      });
    }
  }]);

  return AdaptiveCardRenderer;
}(_react.default.PureComponent);

var _default = (0, _connectToWebChat.default)(function (_ref2) {
  var adaptiveCardHostConfig = _ref2.adaptiveCardHostConfig,
      disabled = _ref2.disabled,
      language = _ref2.language,
      onCardAction = _ref2.onCardAction,
      renderMarkdown = _ref2.renderMarkdown,
      styleSet = _ref2.styleSet,
      tapAction = _ref2.tapAction;
  return {
    adaptiveCardHostConfig: adaptiveCardHostConfig,
    disabled: disabled,
    language: language,
    onCardAction: onCardAction,
    renderMarkdown: renderMarkdown,
    styleSet: styleSet,
    tapAction: tapAction
  };
})(AdaptiveCardRenderer);

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9BdHRhY2htZW50L0FkYXB0aXZlQ2FyZFJlbmRlcmVyLmpzIl0sIm5hbWVzIjpbIkFkYXB0aXZlQ2FyZFJlbmRlcmVyIiwicHJvcHMiLCJoYW5kbGVDbGljayIsImJpbmQiLCJoYW5kbGVFeGVjdXRlQWN0aW9uIiwiY29udGVudFJlZiIsIlJlYWN0IiwiY3JlYXRlUmVmIiwic3RhdGUiLCJlcnJvciIsInJlbmRlckNhcmQiLCJwcmV2UHJvcHMiLCJhZGFwdGl2ZUNhcmQiLCJ0YXJnZXQiLCJkaXNhYmxlZCIsInRhYkluZGV4Iiwib25DYXJkQWN0aW9uIiwidGFwQWN0aW9uIiwiYWN0aW9uIiwiYWN0aW9uVHlwZU5hbWUiLCJnZXRKc29uVHlwZU5hbWUiLCJ0eXBlIiwidmFsdWUiLCJ1cmwiLCJkYXRhIiwiYWN0aW9uRGF0YSIsIl9faXNCb3RGcmFtZXdvcmtDYXJkQWN0aW9uIiwiY2FyZEFjdGlvbiIsImRpc3BsYXlUZXh0IiwiY29uc29sZSIsImN1cnJlbnQiLCJhZGFwdGl2ZUNhcmRIb3N0Q29uZmlnIiwicmVuZGVyTWFya2Rvd24iLCJjb25zdHJ1Y3RvciIsIm9uUHJvY2Vzc01hcmtkb3duIiwidGV4dCIsInJlc3VsdCIsIm91dHB1dEh0bWwiLCJkaWRQcm9jZXNzIiwiaG9zdENvbmZpZyIsIm9uRXhlY3V0ZUFjdGlvbiIsImVycm9ycyIsInZhbGlkYXRlIiwibGVuZ3RoIiwic2V0U3RhdGUiLCJlbGVtZW50IiwicmVuZGVyIiwiZXJyIiwiaHlwZXJsaW5rcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpbnB1dHMiLCJmb3JFYWNoIiwiY2FsbCIsImlucHV0IiwiaHlwZXJsaW5rIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJzdG9wUHJvcGFnYXRpb24iLCJmaXJzdENoaWxkIiwiY2hpbGRyZW4iLCJyZXBsYWNlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsImxhbmd1YWdlIiwic3R5bGVTZXQiLCJKU09OIiwic3RyaW5naWZ5IiwiYWRhcHRpdmVDYXJkUmVuZGVyZXIiLCJQdXJlQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFTUEsb0I7Ozs7O0FBQ0osZ0NBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFBQTs7QUFDakIsOEZBQU1BLEtBQU47QUFFQSxVQUFLQyxXQUFMLEdBQW1CLE1BQUtBLFdBQUwsQ0FBaUJDLElBQWpCLCtCQUFuQjtBQUNBLFVBQUtDLG1CQUFMLEdBQTJCLE1BQUtBLG1CQUFMLENBQXlCRCxJQUF6QiwrQkFBM0I7QUFFQSxVQUFLRSxVQUFMLEdBQWtCQyxlQUFNQyxTQUFOLEVBQWxCO0FBRUEsVUFBS0MsS0FBTCxHQUFhO0FBQ1hDLE1BQUFBLEtBQUssRUFBRTtBQURJLEtBQWI7QUFSaUI7QUFXbEI7Ozs7d0NBRW1CO0FBQ2xCLFdBQUtDLFVBQUw7QUFDRDs7O3VDQUVrQkMsUyxFQUFXO0FBQzVCLFVBQUlBLFNBQVMsQ0FBQ0MsWUFBVixLQUEyQixLQUFLWCxLQUFMLENBQVdXLFlBQTFDLEVBQXdEO0FBQ3RELGFBQUtGLFVBQUw7QUFDRDtBQUNGOzs7c0NBRXVCO0FBQUEsVUFBVkcsTUFBVSxRQUFWQSxNQUFVOztBQUN0QjtBQUNBLFVBQUksS0FBS1osS0FBTCxDQUFXYSxRQUFmLEVBQXlCO0FBQUU7QUFBUzs7QUFFcEMsVUFBTUMsUUFBUSxHQUFHLDBCQUFZRixNQUFaLENBQWpCLENBSnNCLENBTXRCO0FBQ0E7O0FBQ0EsVUFBSSxPQUFPRSxRQUFQLEtBQW9CLFFBQXBCLElBQWdDQSxRQUFRLEdBQUcsQ0FBL0MsRUFBa0Q7QUFBQSwwQkFDRCxJQURDLENBQ3hDZCxLQUR3QztBQUFBLFlBQy9CZSxZQUQrQixlQUMvQkEsWUFEK0I7QUFBQSxZQUNqQkMsU0FEaUIsZUFDakJBLFNBRGlCO0FBR2hEQSxRQUFBQSxTQUFTLElBQUlELFlBQVksQ0FB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QUFBQSxNQU9FaEQsU0FQRixTQU9FQSxTQVBGO0FBQUEsU0FRTztBQUNMYyxJQUFBQSxzQkFBc0IsRUFBdEJBLHNCQURLO0FBRUxqQixJQUFBQSxRQUFRLEVBQVJBLFFBRks7QUFHTGtELElBQUFBLFFBQVEsRUFBUkEsUUFISztBQUlMaEQsSUFBQUEsWUFBWSxFQUFaQSxZQUpLO0FBS0xnQixJQUFBQSxjQUFjLEVBQWRBLGNBTEs7QUFNTGlDLElBQUFBLFFBQVEsRUFBUkEsUUFOSztBQU9MaEQsSUFBQUEsU0FBUyxFQUFUQTtBQVBLLEdBUlA7QUFBQSxDQURhLEVBa0JiakIsb0JBbEJhLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBsb2NhbGl6ZSB9IGZyb20gJy4uL0xvY2FsaXphdGlvbi9Mb2NhbGl6ZSc7XG5pbXBvcnQgY29ubmVjdFRvV2ViQ2hhdCBmcm9tICcuLi9jb25uZWN0VG9XZWJDaGF0JztcbmltcG9ydCBFcnJvckJveCBmcm9tICcuLi9FcnJvckJveCc7XG5pbXBvcnQgZ2V0VGFiSW5kZXggZnJvbSAnLi4vVXRpbHMvVHlwZUZvY3VzU2luay9nZXRUYWJJbmRleCc7XG5cbmNsYXNzIEFkYXB0aXZlQ2FyZFJlbmRlcmVyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5oYW5kbGVDbGljayA9IHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUV4ZWN1dGVBY3Rpb24gPSB0aGlzLmhhbmRsZUV4ZWN1dGVBY3Rpb24uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuY29udGVudFJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMucmVuZGVyQ2FyZCgpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmIChwcmV2UHJvcHMuYWRhcHRpdmVDYXJkICE9PSB0aGlzLnByb3BzLmFkYXB0aXZlQ2FyZCkge1xuICAgICAgdGhpcy5yZW5kZXJDYXJkKCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQ2xpY2soeyB0YXJnZXQgfSkge1xuICAgIC8vIFNvbWUgaXRlbXMsIGUuZy4gdGFwcGFibGUgdGV4dCwgY2Fubm90IGJlIGRpc2FibGVkIHRocnUgRE9NIGF0dHJpYnV0ZXNcbiAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IHRhYkluZGV4ID0gZ2V0VGFiSW5kZXgodGFyZ2V0KTtcblxuICAgIC8vIElmIHRoZSB1c2VyIGlzIGNsaWNraW5nIG9uIHNvbWV0aGluZyB0aGF0IGlzIGFscmVhZHkgY2xpY2thYmxlLCBkbyBub3QgYWxsb3cgdGhlbSB0byBjbGljayB0aGUgY2FyZC5cbiAgICAvLyBFLmcuIGEgaGVybyBjYXJkIGNhbiBiZSB0YXBwYWJsZSwgYW5kIGltYWdlIGFuZCBidXR0b25zIGluc2lkZSB0aGUgaGVybyBjYXJkIGNhbiBhbHNvIGJlIHRhcHBhYmxlLlxuICAgIGlmICh0eXBlb2YgdGFiSW5kZXggIT09ICdudW1iZXInIHx8IHRhYkluZGV4IDwgMCkge1xuICAgICAgY29uc3QgeyBwcm9wczogeyBvbkNhcmRBY3Rpb24sIHRhcEFjdGlvbiB9IH0gPSB0aGlzO1xuXG4gICAgICB0YXBBY3Rpb24gJiYgb25DYXJkQWN0aW9uKHRhcEFjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRXhlY3V0ZUFjdGlvbihhY3Rpb24pIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuXG4gICAgLy8gU29tZSBpdGVtcywgZS5nLiB0YXBwYWJsZSBpbWFnZSwgY2Fubm90IGJlIGRpc2FibGVkIHRocnUgRE9NIGF0dHJpYnV0ZXNcbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBhY3Rpb25UeXBlTmFtZSA9IGFjdGlvbi5nZXRKc29uVHlwZU5hbWUoKTtcblxuICAgIGlmIChhY3Rpb25UeXBlTmFtZSA9PT0gJ0FjdGlvbi5PcGVuVXJsJykge1xuICAgICAgcHJvcHMub25DYXJkQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ29wZW5VcmwnLFxuICAgICAgICB2YWx1ZTogYWN0aW9uLnVybFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChhY3Rpb25UeXBlTmFtZSA9PT0gJ0FjdGlvbi5TdWJtaXQnKSB7XG4gICAgICBpZiAodHlwZW9mIGFjdGlvbi5kYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCB7IGRhdGE6IGFjdGlvbkRhdGEgfSA9IGFjdGlvbjtcblxuICAgICAgICBpZiAoYWN0aW9uRGF0YSAmJiBhY3Rpb25EYXRhLl9faXNCb3RGcmFtZXdvcmtDYXJkQWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgeyBjYXJkQWN0aW9uIH0gPSBhY3Rpb25EYXRhO1xuICAgICAgICAgIGNvbnN0IHsgZGlzcGxheVRleHQsIHR5cGUsIHZhbHVlIH0gPSBjYXJkQWN0aW9uO1xuXG4gICAgICAgICAgcHJvcHMub25DYXJkQWN0aW9uKHsgZGlzcGxheVRleHQsIHR5cGUsIHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzLm9uQ2FyZEFjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiB0eXBlb2YgYWN0aW9uLmRhdGEgPT09ICdzdHJpbmcnID8gJ2ltQmFjaycgOiAncG9zdEJhY2snLFxuICAgICAgICAgICAgdmFsdWU6IGFjdGlvbi5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgV2ViIENoYXQ6IHJlY2VpdmVkIHVua25vd24gYWN0aW9uIGZyb20gQWRhcHRpdmUgQ2FyZHNgKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXJDYXJkKCkge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdGhpcy5jb250ZW50UmVmO1xuICAgIGNvbnN0IHsgcHJvcHM6IHsgYWRhcHRpdmVDYXJkLCBhZGFwdGl2ZUNhcmRIb3N0Q29uZmlnLCByZW5kZXJNYXJrZG93biB9IH0gPSB0aGlzO1xuXG4gICAgaWYgKGN1cnJlbnQgJiYgYWRhcHRpdmVDYXJkKSB7XG4gICAgICAvLyBDdXJyZW50bHksIHRoZSBvbmx5IHdheSB0byBzZXQgdGhlIE1hcmtkb3duIGVuZ2luZSBpcyB0byBzZXQgaXQgdGhydSBzdGF0aWMgbWVtYmVyIG9mIEFkYXB0aXZlQ2FyZCBjbGFzc1xuXG4gICAgICAvLyBUT0RPOiBbUDNdIENoZWNrcyBpZiB3ZSBjb3VsZCBtYWtlIHRoZSBcInJlbmRlck1hcmtkb3duXCIgcGVyIGNhcmRcbiAgICAgIC8vICAgICAgIFRoaXMgY291bGQgYmUgbGltaXRhdGlvbnMgZnJvbSBBZGFwdGl2ZSBDYXJkcyBwYWNrYWdlXG4gICAgICAvLyAgICAgICBCZWNhdXNlIHRoZXJlIGNvdWxkIGJlIHRpbWluZyBkaWZmZXJlbmNlIGJldHdlZW4gLnBhcnNlIGFuZCAucmVuZGVyLCB3ZSBjb3VsZCBiZSB1c2luZyB3cm9uZyBNYXJrZG93biBlbmdpbmVcblxuICAgICAgYWRhcHRpdmVDYXJkLmNvbnN0cnVjdG9yLm9uUHJvY2Vzc01hcmtkb3duID0gKHRleHQsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocmVuZGVyTWFya2Rvd24pIHtcbiAgICAgICAgICByZXN1bHQub3V0cHV0SHRtbCA9IHJlbmRlck1hcmtkb3duKHRleHQpO1xuICAgICAgICAgIHJlc3VsdC5kaWRQcm9jZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgYWRhcHRpdmVDYXJkLmhvc3RDb25maWcgPSBhZGFwdGl2ZUNhcmRIb3N0Q29uZmlnO1xuICAgICAgYWRhcHRpdmVDYXJkLm9uRXhlY3V0ZUFjdGlvbiA9IHRoaXMuaGFuZGxlRXhlY3V0ZUFjdGlvbjtcblxuICAgICAgY29uc3QgZXJyb3JzID0gYWRhcHRpdmVDYXJkLnZhbGlkYXRlKCk7XG5cbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKCgpID0+ICh7IGVycm9yOiBlcnJvcnMgfSkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgZWxlbWVudDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZWxlbWVudCA9IGFkYXB0aXZlQ2FyZC5yZW5kZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBlcnJvcnM6IGVyciB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyBlcnJvcjogJ0FkYXB0aXZlIENhcmQgcmVuZGVyZWQgYXMgZW1wdHkgZWxlbWVudCcgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IGVycm9yOiBudWxsIH0pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgY29uc3QgaHlwZXJsaW5rcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYScpO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbiwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKTtcblxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwoaW5wdXRzLCBpbnB1dCA9PiB7XG4gICAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBbXS5mb3JFYWNoLmNhbGwoaHlwZXJsaW5rcywgaHlwZXJsaW5rID0+IHtcbiAgICAgICAgICBoeXBlcmxpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBjdXJyZW50LmNoaWxkcmVuWzBdO1xuXG4gICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICBjdXJyZW50LnJlcGxhY2VDaGlsZChlbGVtZW50LCBmaXJzdENoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3BzOiB7IGxhbmd1YWdlLCBzdHlsZVNldCB9LFxuICAgICAgc3RhdGU6IHsgZXJyb3IgfVxuICAgIH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIGVycm9yID9cbiAgICAgICAgPEVycm9yQm94IG1lc3NhZ2U9eyBsb2NhbGl6ZSgnQWRhcHRpdmUgQ2FyZCByZW5kZXIgZXJyb3InLCBsYW5ndWFnZSkgfT5cbiAgICAgICAgICA8cHJlPnsgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpIH08L3ByZT5cbiAgICAgICAgPC9FcnJvckJveD5cbiAgICAgIDpcbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17IHN0eWxlU2V0LmFkYXB0aXZlQ2FyZFJlbmRlcmVyIH1cbiAgICAgICAgICBvbkNsaWNrPXsgdGhpcy5oYW5kbGVDbGljayB9XG4gICAgICAgICAgcmVmPXsgdGhpcy5jb250ZW50UmVmIH1cbiAgICAgICAgLz5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RUb1dlYkNoYXQoXG4gICh7XG4gICAgYWRhcHRpdmVDYXJkSG9zdENvbmZpZyxcbiAgICBkaXNhYmxlZCxcbiAgICBsYW5ndWFnZSxcbiAgICBvbkNhcmRBY3Rpb24sXG4gICAgcmVuZGVyTWFya2Rvd24sXG4gICAgc3R5bGVTZXQsXG4gICAgdGFwQWN0aW9uXG4gIH0pID0+ICh7XG4gICAgYWRhcHRpdmVDYXJkSG9zdENvbmZpZyxcbiAgICBkaXNhYmxlZCxcbiAgICBsYW5ndWFnZSxcbiAgICBvbkNhcmRBY3Rpb24sXG4gICAgcmVuZGVyTWFya2Rvd24sXG4gICAgc3R5bGVTZXQsXG4gICAgdGFwQWN0aW9uXG4gIH0pXG4pKEFkYXB0aXZlQ2FyZFJlbmRlcmVyKVxuIl19