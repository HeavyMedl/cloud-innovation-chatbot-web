{"version":3,"sources":["../../../src/SpeechServices/SpeechToText/createSpeechRecognitionPonyfill.js"],"names":["AudioConfig","SpeechSDK","OutputFormat","ResultReason","SpeechConfig","SpeechRecognizer","serializeRecognitionResult","duration","errorDetails","json","offset","properties","reason","resultId","text","JSON","parse","authorizationToken","region","subscriptionKey","textNormalization","console","warn","window","navigator","mediaDevices","getUserMedia","audioConfig","fromDefaultMicrophoneInput","SpeechRecognition","_continuous","_interimResults","_lang","document","documentElement","getAttribute","language","_maxAlternatives","fromAuthorizationToken","fromSubscription","speechConfig","outputFormat","Detailed","speechRecognitionLanguage","lang","type","event","emit","subType","continuous","Error","_startOnce","catch","err","error","message","createRecognizer","recognizer","queue","canceled","_","sessionId","push","recognized","result","recognizing","recognizeOnceAsync","success","abort","stop","loop","shift","Object","keys","forEach","name","emitCognitiveServices","errorMessage","test","finalEvent","audioStarted","stopping","lastRecognizingResults","isFinal","results","speechStarted","NoMatch","maxAlternatives","interimResults","dispose","value","DOMEventEmitter","SpeechGrammarList"],"mappings":"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","sourcesContent":["import memoize from 'memoize-one';\n\nimport cognitiveServiceEventResultToWebSpeechRecognitionResultList from './cognitiveServiceEventResultToWebSpeechRecognitionResultList';\nimport createPromiseQueue from '../../Util/createPromiseQueue';\nimport DOMEventEmitter from '../../Util/DOMEventEmitter';\nimport SpeechGrammarList from './SpeechGrammarList';\nimport SpeechSDK from '../SpeechSDK';\n\n// https://docs.microsoft.com/en-us/javascript/api/microsoft-cognitiveservices-speech-sdk/speechconfig?view=azure-node-latest#outputformat\n// {\n//   \"RecognitionStatus\": \"Success\",\n//   \"Offset\": 900000,\n//   \"Duration\": 49000000,\n//   \"NBest\": [\n//     {\n//       \"Confidence\": 0.738919,\n//       \"Lexical\": \"second\",\n//       \"ITN\": \"second\",\n//       \"MaskedITN\": \"second\",\n//       \"Display\": \"Second.\"\n//     }\n//   ]\n// }\n\n// {\n//   \"RecognitionStatus\": \"InitialSilenceTimeout\",\n//   \"Offset\": 50000000,\n//   \"Duration\": 0\n// }\n\nconst {\n  AudioConfig,\n  OutputFormat,\n  ResultReason,\n  SpeechConfig,\n  SpeechRecognizer\n} = SpeechSDK;\n\nfunction serializeRecognitionResult({\n  duration,\n  errorDetails,\n  json,\n  offset,\n  properties,\n  reason,\n  resultId,\n  text\n}) {\n  return {\n    duration,\n    errorDetails,\n    json: JSON.parse(json),\n    offset,\n    properties,\n    reason,\n    resultId,\n    text\n  };\n}\n\nexport default async ({\n  authorizationToken,\n  region = 'westus',\n  subscriptionKey,\n  textNormalization = 'display'\n} = {}) => {\n  if (!authorizationToken && !subscriptionKey) {\n    console.warn('Either authorizationToken or subscriptionKey must be specified');\n\n    return {};\n  } else if (!window.navigator.mediaDevices || !window.navigator.mediaDevices.getUserMedia) {\n    console.warn('This browser does not support WebRTC and it will not work with Cognitive Services Speech Services.');\n\n    return {};\n  }\n\n  const audioConfig = AudioConfig.fromDefaultMicrophoneInput();\n\n  class SpeechRecognition extends DOMEventEmitter {\n    constructor() {\n      super([\n        'audiostart',\n        'soundstart',\n        'speechstart',\n        'speechend',\n        'soundend',\n        'audioend',\n        'result',\n        'nomatch',\n        'error',\n        'start',\n        'end',\n        'cognitiveservices'\n      ]);\n\n      this._continuous = false;\n      this._interimResults = false;\n      this._lang = typeof window !== 'undefined' ? (window.document.documentElement.getAttribute('lang') || window.navigator.language) : 'en-US';\n      this._maxAlternatives = 1;\n    }\n\n    async createRecognizer() {\n      const speechConfig = authorizationToken ?\n        SpeechConfig.fromAuthorizationToken(typeof authorizationToken === 'function' ? await authorizationToken() : await authorizationToken, region)\n      :\n        SpeechConfig.fromSubscription(subscriptionKey, region);\n\n      speechConfig.outputFormat = OutputFormat.Detailed;\n      speechConfig.speechRecognitionLanguage = this.lang || 'en-US';\n\n      return new SpeechRecognizer(speechConfig, audioConfig);\n    }\n\n    emitCognitiveServices(type, event) {\n      this.emit('cognitiveservices', {\n        ...event,\n        subType: type\n      });\n    }\n\n    get continuous() { return this._continuous; }\n    set continuous(value) { value && console.warn(`Speech Services: Cannot set continuous to ${ value }, this feature is not supported.`); }\n\n    get interimResults() { return this._interimResults; }\n    set interimResults(value) { this._interimResults = value; }\n\n    get maxAlternatives() { return this._maxAlternatives; }\n    set maxAlternatives(value) { this._maxAlternatives = value; }\n\n    get lang() { return this._lang; }\n    set lang(value) { this._lang = value; }\n\n    abort() {}\n\n    start() {\n      if (this.continuous) {\n        throw new Error('Continuous mode is not supported.');\n      } else {\n        this._startOnce().catch(err => {\n          console.error(err);\n          this.emit('error', { error: err, message: err && err.message });\n        });\n      }\n    }\n\n    async _startOnce() {\n      // TODO: [P2] Should check if recognition is active, we should not start recognition twice\n      const recognizer = await this.createRecognizer();\n      const queue = createPromiseQueue();\n      let lastRecognizingResults;\n      let speechStarted;\n      let stopping;\n\n      recognizer.canceled = (_, { errorDetails, offset, reason, sessionId }) => {\n        queue.push({\n          canceled: {\n            errorDetails,\n            offset,\n            reason,\n            sessionId\n          }\n        });\n      };\n\n      recognizer.recognized = (_, { offset, result, sessionId }) => {\n        queue.push({\n          recognized: {\n            offset,\n            result: serializeRecognitionResult(result),\n            sessionId\n          }\n        });\n      };\n\n      recognizer.recognizing = (_, { offset, result, sessionId }) => {\n        queue.push({\n          recognizing: {\n            offset,\n            result: serializeRecognitionResult(result),\n            sessionId\n          }\n        });\n      };\n\n      recognizer.recognizeOnceAsync(\n        result => queue.push({ success: serializeRecognitionResult(result) }),\n        err => queue.push({ error: err })\n      );\n\n      this.abort = () => queue.push({ abort: {} });\n      this.stop = () => queue.push({ stop: {} });\n\n      let audioStarted;\n      let finalEvent;\n\n      for (let loop = 0;; loop++) {\n        const event = await queue.shift();\n        const {\n          abort,\n          canceled,\n          error,\n          recognized,\n          recognizing,\n          stop,\n          success\n        } = event;\n\n        // We are emitting event \"cognitiveservices\" for debugging purpose\n        Object.keys(event).forEach(name => this.emitCognitiveServices(name, event[name]));\n\n        let errorMessage = error ? error : canceled && canceled.errorDetails;\n\n        if (errorMessage && /Permission\\sdenied/.test(errorMessage)) {\n          finalEvent = {\n            error: 'not-allowed',\n            type: 'error'\n          };\n\n          break;\n        }\n\n        if (!loop) {\n          this.emit('start');\n          this.emit('audiostart');\n\n          audioStarted = true;\n        }\n\n        if (errorMessage) {\n          if (/1006/.test(errorMessage)) {\n            finalEvent = {\n              error: 'network',\n              type: 'error'\n            };\n          } else {\n            finalEvent = {\n              error: 'unknown',\n              type: 'error'\n            };\n          }\n\n          break;\n        } else if (abort || stop) {\n          stopping = true;\n\n          if (abort) {\n            finalEvent = {\n              error: 'aborted',\n              type: 'error'\n            };\n          } else if (lastRecognizingResults) {\n            lastRecognizingResults.isFinal = true;\n\n            finalEvent = {\n              results: lastRecognizingResults,\n              type: 'result'\n            };\n          }\n\n          if (speechStarted) {\n            this.emit('speechend');\n            this.emit('soundend');\n\n            speechStarted = false;\n          }\n        } else if (!stopping) {\n          if (recognized && recognized.result && recognized.result.reason === ResultReason.NoMatch) {\n            finalEvent = {\n              error: 'no-speech',\n              type: 'error'\n            };\n          } else {\n            if (!loop) {\n              this.emit('soundstart');\n              this.emit('speechstart');\n\n              speechStarted = true;\n            }\n\n            if (recognized) {\n              finalEvent = {\n                results: cognitiveServiceEventResultToWebSpeechRecognitionResultList(\n                  recognized.result,\n                  {\n                    maxAlternatives: this.maxAlternatives,\n                    textNormalization\n                  }\n                ),\n                type: 'result'\n              };\n\n              break;\n            } else if (recognizing) {\n              lastRecognizingResults = cognitiveServiceEventResultToWebSpeechRecognitionResultList(\n                recognizing.result,\n                {\n                  maxAlternatives: this.maxAlternatives,\n                  textNormalization\n                }\n              );\n\n              this.interimResults && this.emit('result', {\n                results: lastRecognizingResults\n              });\n            }\n          }\n        }\n\n        if (error || success) {\n          break;\n        }\n      }\n\n      // TODO: We should emit \"audioend\", \"result\", or \"error\" here\n      //       This is for mimicking stop() behavior, \"audioend\" should not fire too early until we received the last \"recognized\" event\n\n      if (speechStarted) {\n        this.emit('speechend');\n        this.emit('soundend');\n      }\n\n      if (audioStarted) {\n        this.emit('audioend');\n      }\n\n      if (finalEvent) {\n        this.emit(finalEvent.type, finalEvent);\n      }\n\n      // Even though there is no \"start\" event emitted, we will still emit \"end\" event\n      // This is mainly for \"microphone blocked\" story.\n      this.emit('end');\n\n      recognizer.dispose();\n    }\n\n    stop() {}\n  }\n\n  return {\n    SpeechGrammarList,\n    SpeechRecognition\n  };\n}\n"],"file":"createSpeechRecognitionPonyfill.js"}