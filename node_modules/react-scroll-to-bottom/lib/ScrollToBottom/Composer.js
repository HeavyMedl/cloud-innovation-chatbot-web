"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _simpleUpdateIn = _interopRequireDefault(require("simple-update-in"));

var _EventSpy = _interopRequireDefault(require("../EventSpy"));

var _FunctionContext = _interopRequireDefault(require("./FunctionContext"));

var _InternalContext = _interopRequireDefault(require("./InternalContext"));

var _SpineTo = _interopRequireDefault(require("../SpineTo"));

var _StateContext = _interopRequireDefault(require("./StateContext"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var MIN_CHECK_INTERVAL = 17; // 1 frame

var NEAR_END_THRESHOLD = 1;
var SCROLL_DECISION_DURATION = 34; // 2 frames

function setImmediateInterval(fn, ms) {
  fn();
  return setInterval(fn, ms);
}

function computeViewState(_ref) {
  var mode = _ref.stateContext.mode,
      _ref$target = _ref.target,
      offsetHeight = _ref$target.offsetHeight,
      scrollHeight = _ref$target.scrollHeight,
      scrollTop = _ref$target.scrollTop;
  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;
  var atTop = scrollTop < NEAR_END_THRESHOLD;
  var atEnd = mode === 'top' ? atTop : atBottom;
  return {
    atBottom: atBottom,
    atEnd: atEnd,
    atStart: !atEnd,
    atTop: atTop
  };
}

var Composer =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Composer, _React$Component);

  function Composer(props) {
    var _this;

    _classCallCheck(this, Composer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Composer).call(this, props));
    _this.handleScroll = _this.handleScroll.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleScrollEnd = _this.handleScrollEnd.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._ignoreScrollEventBefore = 0;
    _this.state = {
      functionContext: {
        scrollTo: function scrollTo(scrollTop) {
          return _this.setState(function (_ref2) {
            var stateContext = _ref2.stateContext;
            return {
              scrollTop: scrollTop,
              stateContext: (0, _simpleUpdateIn.default)(stateContext, ['animating'], function () {
                return true;
              })
            };
          });
        },
        scrollToBottom: function scrollToBottom() {
          return _this.state.functionContext.scrollTo('100%');
        },
        scrollToEnd: function scrollToEnd() {
          var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)),
              _assertThisInitialize2 = _assertThisInitialize.state,
              functionContext = _assertThisInitialize2.functionContext,
              stateContext = _assertThisInitialize2.stateContext;

          stateContext.mode === 'top' ? functionContext.scrollToTop() : functionContext.scrollToBottom();
        },
        scrollToStart: function scrollToStart() {
          var _assertThisInitialize3 = _assertThisInitialized(_assertThisInitialized(_this)),
              _assertThisInitialize4 = _assertThisInitialize3.state,
              functionContext = _assertThisInitialize4.functionContext,
              stateContext = _assertThisInitialize4.stateContext;

          stateContext.mode === 'top' ? functionContext.scrollToBottom() : functionContext.scrollToTop();
        },
        scrollToTop: function scrollToTop() {
          return _this.state.functionContext.scrollTo(0);
        }
      },
      internalContext: {
        setTarget: function setTarget(target) {
          return _this.setState(function () {
            return {
              target: target
            };
          });
        }
      },
      scrollTop: props.mode === 'top' ? 0 : '100%',
      stateContext: {
        animating: false,
        atBottom: true,
        atEnd: true,
        atTop: true,
        mode: props.mode,
        sticky: true
      },
      target: null
    };
    return _this;
  }

  _createClass(Composer, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.enableWorker();
    }
  }, {
    key: "disableWorker",
    value: function disableWorker() {
      clearInterval(this._stickyCheckTimeout);
    }
  }, {
    key: "enableWorker",
    value: function enableWorker() {
      var _this2 = this;

      clearInterval(this._stickyCheckTimeout);
      var stickyButNotAtEndSince = false;
      this._stickyCheckTimeout = setImmediateInterval(function () {
        var state = _this2.state;
        var sticky = state.stateContext.sticky,
            target = state.target;

        if (sticky && target && !computeViewState(state).atEnd) {
          if (!stickyButNotAtEndSince) {
            stickyButNotAtEndSince = Date.now();
          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {
            // Quirks: In Firefox, after user scroll down, Firefox do two things:
            //         1. Set to a new "scrollTop"
            //         2. Fire "scroll" event
            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.
            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.
            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.
            state.functionContext.scrollToEnd();
            stickyButNotAtEndSince = false;
          }
        } else {
          stickyButNotAtEndSince = false;
        }
      }, Math.max(MIN_CHECK_INTERVAL, this.props.checkInterval) || MIN_CHECK_INTERVAL);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.disableWorker();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      this.setState(function (_ref3) {
        var stateContext = _ref3.stateContext;
        return {
          stateContext: _objectSpread({}, stateContext, {
            mode: nextProps.mode === 'top' ? 'top' : 'bottom'
          })
        };
      });
    }
  }, {
    key: "handleScroll",
    value: function handleScroll(_ref4) {
      var _this3 = this;

      var timeStampLow = _ref4.timeStampLow;

      // Currently, there are no reliable way to check if the "scroll" event is trigger due to
      // user gesture, programmatic scrolling, or Chrome-synthesized "scroll" event to compensate size change.
      // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.
      if (timeStampLow <= this._ignoreScrollEventBefore) {
        // Since we debounce "scroll" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).
        // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.
        // Thus, on a fast machine, adding elements super fast will lose the "stickiness".
        return;
      }

      this.disableWorker();
      this.setState(function (state) {
        var target = state.target;

        if (target) {
          var scrollTop = state.scrollTop,
              stateContext = state.stateContext;

          var _computeViewState = computeViewState(state),
              atBottom = _computeViewState.atBottom,
              atEnd = _computeViewState.atEnd,
              atStart = _computeViewState.atStart,
              atTop = _computeViewState.atTop;

          var nextStateContext = stateContext;
          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atBottom'], function () {
            return atBottom;
          });
          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atEnd'], function () {
            return atEnd;
          });
          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atStart'], function () {
            return atStart;
          });
          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atTop'], function () {
            return atTop;
          }); // Sticky means:
          // - If it is scrolled programatically, we are still in sticky mode
          // - If it is scrolled by the user, then sticky means if we are at the end

          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['sticky'], function () {
            return stateContext.animating ? true : atEnd;
          }); // If no scrollTop is set (not in programmatic scrolling mode), we should set "animating" to false
          // "animating" is used to calculate the "sticky" property

          if (scrollTop === null) {
            nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['animating'], function () {
              return false;
            });
          }

          if (stateContext !== nextStateContext) {
            return {
              stateContext: nextStateContext
            };
          }
        }
      }, function () {
        _this3.state.stateContext.sticky && _this3.enableWorker();
      });
    }
  }, {
    key: "handleScrollEnd",
    value: function handleScrollEnd() {
      // We should ignore debouncing handleScroll that emit before this time
      this._ignoreScrollEventBefore = Date.now();
      this.setState(function () {
        return {
          scrollTop: null
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      var handleScroll = this.handleScroll,
          handleScrollEnd = this.handleScrollEnd,
          _this$props = this.props,
          children = _this$props.children,
          debounce = _this$props.debounce,
          _this$state = this.state,
          functionContext = _this$state.functionContext,
          internalContext = _this$state.internalContext,
          scrollTop = _this$state.scrollTop,
          stateContext = _this$state.stateContext,
          target = _this$state.target;
      return _react.default.createElement(_InternalContext.default.Provider, {
        value: internalContext
      }, _react.default.createElement(_FunctionContext.default.Provider, {
        value: functionContext
      }, _react.default.createElement(_StateContext.default.Provider, {
        value: stateContext
      }, children, target && _react.default.createElement(_EventSpy.default, {
        debounce: debounce,
        name: "scroll",
        onEvent: handleScroll,
        target: target
      }), target && scrollTop !== null && _react.default.createElement(_SpineTo.default, {
        name: "scrollTop",
        onEnd: handleScrollEnd,
        target: target,
        value: scrollTop
      }))));
    }
  }]);

  return Composer;
}(_react.default.Component);

exports.default = Composer;
Composer.defaultProps = {
  checkInterval: 100,
  debounce: 17
};
Composer.propTypes = {
  checkInterval: _propTypes.default.number,
  debounce: _propTypes.default.number
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9TY3JvbGxUb0JvdHRvbS9Db21wb3Nlci5qcyJdLCJuYW1lcyI6WyJNSU5fQ0hFQ0tfSU5URVJWQUwiLCJORUFSX0VORF9USFJFU0hPTEQiLCJTQ1JPTExfREVDSVNJT05fRFVSQVRJT04iLCJzZXRJbW1lZGlhdGVJbnRlcnZhbCIsImZuIiwibXMiLCJzZXRJbnRlcnZhbCIsImNvbXB1dGVWaWV3U3RhdGUiLCJtb2RlIiwic3RhdGVDb250ZXh0IiwidGFyZ2V0Iiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsVG9wIiwiYXRCb3R0b20iLCJhdFRvcCIsImF0RW5kIiwiYXRTdGFydCIsIkNvbXBvc2VyIiwicHJvcHMiLCJoYW5kbGVTY3JvbGwiLCJiaW5kIiwiaGFuZGxlU2Nyb2xsRW5kIiwiX2lnbm9yZVNjcm9sbEV2ZW50QmVmb3JlIiwic3RhdGUiLCJmdW5jdGlvbkNvbnRleHQiLCJzY3JvbGxUbyIsInNldFN0YXRlIiwic2Nyb2xsVG9Cb3R0b20iLCJzY3JvbGxUb0VuZCIsInNjcm9sbFRvVG9wIiwic2Nyb2xsVG9TdGFydCIsImludGVybmFsQ29udGV4dCIsInNldFRhcmdldCIsImFuaW1hdGluZyIsInN0aWNreSIsImVuYWJsZVdvcmtlciIsImNsZWFySW50ZXJ2YWwiLCJfc3RpY2t5Q2hlY2tUaW1lb3V0Iiwic3RpY2t5QnV0Tm90QXRFbmRTaW5jZSIsIkRhdGUiLCJub3ciLCJNYXRoIiwibWF4IiwiY2hlY2tJbnRlcnZhbCIsImRpc2FibGVXb3JrZXIiLCJuZXh0UHJvcHMiLCJ0aW1lU3RhbXBMb3ciLCJuZXh0U3RhdGVDb250ZXh0IiwiY2hpbGRyZW4iLCJkZWJvdW5jZSIsIlJlYWN0IiwiQ29tcG9uZW50IiwiZGVmYXVsdFByb3BzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwibnVtYmVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FB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LGFBQ0UsNkJBQUMsd0JBQUQsQ0FBaUIsUUFBakI7QUFBMEIsUUFBQSxLQUFLLEVBQUdzQjtBQUFsQyxTQUNFLDZCQUFDLHdCQUFELENBQWlCLFFBQWpCO0FBQTBCLFFBQUEsS0FBSyxFQUFHUDtBQUFsQyxTQUNFLDZCQUFDLHFCQUFELENBQWMsUUFBZDtBQUF1QixRQUFBLEtBQUssRUFBR2hCO0FBQS9CLFNBQ0l3QyxRQURKLEVBR0l2QyxNQUFNLElBQ0osNkJBQUMsaUJBQUQ7QUFDRSxRQUFBLFFBQVEsRUFBR3dDLFFBRGI7QUFFRSxRQUFBLElBQUksRUFBQyxRQUZQO0FBR0UsUUFBQSxPQUFPLEVBQUc5QixZQUhaO0FBSUUsUUFBQSxNQUFNLEVBQUdWO0FBSlgsUUFKTixFQVlJQSxNQUFNLElBQUlHLFNBQVMsS0FBSyxJQUF4QixJQUNFLDZCQUFDLGdCQUFEO0FBQ0UsUUFBQSxJQUFJLEVBQUMsV0FEUDtBQUVFLFFBQUEsS0FBSyxFQUFHUyxlQUZWO0FBR0UsUUFBQSxNQUFNLEVBQUdaLE1BSFg7QUFJRSxRQUFBLEtBQUssRUFBR0c7QUFKVixRQWJOLENBREYsQ0FERixDQURGO0FBMkJEOzs7O0VBL0xtQ3NDLGVBQU1DLFM7OztBQWtNNUNsQyxRQUFRLENBQUNtQyxZQUFULEdBQXdCO0FBQ3RCVCxFQUFBQSxhQUFhLEVBQUUsR0FETztBQUV0Qk0sRUFBQUEsUUFBUSxFQUFFO0FBRlksQ0FBeEI7QUFLQWhDLFFBQVEsQ0FBQ29DLFNBQVQsR0FBcUI7QUFDbkJWLEVBQUFBLGFBQWEsRUFBRVcsbUJBQVVDLE1BRE47QUFFbkJOLEVBQUFBLFFBQVEsRUFBRUssbUJBQVVDO0FBRkQsQ0FBckIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1cGRhdGVJbiBmcm9tICdzaW1wbGUtdXBkYXRlLWluJztcblxuaW1wb3J0IEV2ZW50U3B5IGZyb20gJy4uL0V2ZW50U3B5JztcbmltcG9ydCBGdW5jdGlvbkNvbnRleHQgZnJvbSAnLi9GdW5jdGlvbkNvbnRleHQnO1xuaW1wb3J0IEludGVybmFsQ29udGV4dCBmcm9tICcuL0ludGVybmFsQ29udGV4dCc7XG5pbXBvcnQgU3BpbmVUbyBmcm9tICcuLi9TcGluZVRvJztcbmltcG9ydCBTdGF0ZUNvbnRleHQgZnJvbSAnLi9TdGF0ZUNvbnRleHQnO1xuXG5jb25zdCBNSU5fQ0hFQ0tfSU5URVJWQUwgPSAxNzsgICAgICAgLy8gMSBmcmFtZVxuY29uc3QgTkVBUl9FTkRfVEhSRVNIT0xEID0gMTtcbmNvbnN0IFNDUk9MTF9ERUNJU0lPTl9EVVJBVElPTiA9IDM0OyAvLyAyIGZyYW1lc1xuXG5mdW5jdGlvbiBzZXRJbW1lZGlhdGVJbnRlcnZhbChmbiwgbXMpIHtcbiAgZm4oKTtcblxuICByZXR1cm4gc2V0SW50ZXJ2YWwoZm4sIG1zKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVZpZXdTdGF0ZSh7IHN0YXRlQ29udGV4dDogeyBtb2RlIH0sIHRhcmdldDogeyBvZmZzZXRIZWlnaHQsIHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wIH0gfSkge1xuICBjb25zdCBhdEJvdHRvbSA9IHNjcm9sbEhlaWdodCAtIHNjcm9sbFRvcCAtIG9mZnNldEhlaWdodCA8IE5FQVJfRU5EX1RIUkVTSE9MRDtcbiAgY29uc3QgYXRUb3AgPSBzY3JvbGxUb3AgPCBORUFSX0VORF9USFJFU0hPTEQ7XG4gIGNvbnN0IGF0RW5kID0gbW9kZSA9PT0gJ3RvcCcgPyBhdFRvcCA6IGF0Qm90dG9tO1xuXG4gIHJldHVybiB7XG4gICAgYXRCb3R0b20sXG4gICAgYXRFbmQsXG4gICAgYXRTdGFydDogIWF0RW5kLFxuICAgIGF0VG9wXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBvc2VyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLmhhbmRsZVNjcm9sbCA9IHRoaXMuaGFuZGxlU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVTY3JvbGxFbmQgPSB0aGlzLmhhbmRsZVNjcm9sbEVuZC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5faWdub3JlU2Nyb2xsRXZlbnRCZWZvcmUgPSAwO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGZ1bmN0aW9uQ29udGV4dDoge1xuICAgICAgICBzY3JvbGxUbzogc2Nyb2xsVG9wID0+IHRoaXMuc2V0U3RhdGUoKHsgc3RhdGVDb250ZXh0IH0pID0+ICh7XG4gICAgICAgICAgc2Nyb2xsVG9wLFxuICAgICAgICAgIHN0YXRlQ29udGV4dDogdXBkYXRlSW4oc3RhdGVDb250ZXh0LCBbJ2FuaW1hdGluZyddLCAoKSA9PiB0cnVlKVxuICAgICAgICB9KSksXG4gICAgICAgIHNjcm9sbFRvQm90dG9tOiAoKSA9PiB0aGlzLnN0YXRlLmZ1bmN0aW9uQ29udGV4dC5zY3JvbGxUbygnMTAwJScpLFxuICAgICAgICBzY3JvbGxUb0VuZDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgc3RhdGU6IHsgZnVuY3Rpb25Db250ZXh0LCBzdGF0ZUNvbnRleHQgfSB9ID0gdGhpcztcblxuICAgICAgICAgIHN0YXRlQ29udGV4dC5tb2RlID09PSAndG9wJyA/IGZ1bmN0aW9uQ29udGV4dC5zY3JvbGxUb1RvcCgpIDogZnVuY3Rpb25Db250ZXh0LnNjcm9sbFRvQm90dG9tKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbFRvU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHN0YXRlOiB7IGZ1bmN0aW9uQ29udGV4dCwgc3RhdGVDb250ZXh0IH0gfSA9IHRoaXM7XG5cbiAgICAgICAgICBzdGF0ZUNvbnRleHQubW9kZSA9PT0gJ3RvcCcgPyBmdW5jdGlvbkNvbnRleHQuc2Nyb2xsVG9Cb3R0b20oKSA6IGZ1bmN0aW9uQ29udGV4dC5zY3JvbGxUb1RvcCgpO1xuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxUb1RvcDogKCkgPT4gdGhpcy5zdGF0ZS5mdW5jdGlvbkNvbnRleHQuc2Nyb2xsVG8oMClcbiAgICAgIH0sXG4gICAgICBpbnRlcm5hbENvbnRleHQ6IHtcbiAgICAgICAgc2V0VGFyZ2V0OiB0YXJnZXQgPT4gdGhpcy5zZXRTdGF0ZSgoKSA9PiAoeyB0YXJnZXQgfSkpXG4gICAgICB9LFxuICAgICAgc2Nyb2xsVG9wOiBwcm9wcy5tb2RlID09PSAndG9wJyA/IDAgOiAnMTAwJScsXG4gICAgICBzdGF0ZUNvbnRleHQ6IHtcbiAgICAgICAgYW5pbWF0aW5nOiBmYWxzZSxcbiAgICAgICAgYXRCb3R0b206IHRydWUsXG4gICAgICAgIGF0RW5kOiB0cnVlLFxuICAgICAgICBhdFRvcDogdHJ1ZSxcbiAgICAgICAgbW9kZTogcHJvcHMubW9kZSxcbiAgICAgICAgc3RpY2t5OiB0cnVlXG4gICAgICB9LFxuICAgICAgdGFyZ2V0OiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuZW5hYmxlV29ya2VyKCk7XG4gIH1cblxuICBkaXNhYmxlV29ya2VyKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fc3RpY2t5Q2hlY2tUaW1lb3V0KTtcbiAgfVxuXG4gIGVuYWJsZVdvcmtlcigpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX3N0aWNreUNoZWNrVGltZW91dCk7XG5cbiAgICBsZXQgc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fc3RpY2t5Q2hlY2tUaW1lb3V0ID0gc2V0SW1tZWRpYXRlSW50ZXJ2YWwoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RhdGVDb250ZXh0OiB7IHN0aWNreSB9LCB0YXJnZXQgfSA9IHN0YXRlO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdGlja3lcbiAgICAgICAgICAmJiB0YXJnZXRcbiAgICAgICAgICAmJiAhY29tcHV0ZVZpZXdTdGF0ZShzdGF0ZSkuYXRFbmRcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKCFzdGlja3lCdXROb3RBdEVuZFNpbmNlKSB7XG4gICAgICAgICAgICBzdGlja3lCdXROb3RBdEVuZFNpbmNlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKERhdGUubm93KCkgLSBzdGlja3lCdXROb3RBdEVuZFNpbmNlID4gU0NST0xMX0RFQ0lTSU9OX0RVUkFUSU9OKSB7XG4gICAgICAgICAgICAvLyBRdWlya3M6IEluIEZpcmVmb3gsIGFmdGVyIHVzZXIgc2Nyb2xsIGRvd24sIEZpcmVmb3ggZG8gdHdvIHRoaW5nczpcbiAgICAgICAgICAgIC8vICAgICAgICAgMS4gU2V0IHRvIGEgbmV3IFwic2Nyb2xsVG9wXCJcbiAgICAgICAgICAgIC8vICAgICAgICAgMi4gRmlyZSBcInNjcm9sbFwiIGV2ZW50XG4gICAgICAgICAgICAvLyAgICAgICAgIEZvciB3aGF0IHdlIG9ic2VydmVkLCAjMSBpcyBmaXJlZCBhYm91dCAyMG1zIGJlZm9yZSAjMi4gVGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB0aGlzIHN0aWNreUNoZWNrVGltZW91dCBpcyBiZWluZyBzY2hlZHVsZWQgYmV0d2VlbiAxIGFuZCAyLlxuICAgICAgICAgICAgLy8gICAgICAgICBUaGF0IG1lYW5zLCBpZiB3ZSBqdXN0IGxvb2sgYXQgIzEgdG8gZGVjaWRlIGlmIHdlIHNob3VsZCBzY3JvbGwsIHdlIHdpbGwgYWx3YXlzIHNjcm9sbCwgaW4gb3Bwb3NlIHRvIHRoZSB1c2VyJ3MgaW50ZW50aW9uLlxuICAgICAgICAgICAgLy8gUmVwcm86IE9wZW4gRmlyZWZveCwgc2V0IGNoZWNrSW50ZXJ2YWwgdG8gYSBsb3dlciBudW1iZXIsIGFuZCB0cnkgdG8gc2Nyb2xsIGJ5IGRyYWdnaW5nIHRoZSBzY3JvbGwgaGFuZGxlci4gSXQgd2lsbCBqdW1wIGJhY2suXG5cbiAgICAgICAgICAgIHN0YXRlLmZ1bmN0aW9uQ29udGV4dC5zY3JvbGxUb0VuZCgpO1xuICAgICAgICAgICAgc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGlja3lCdXROb3RBdEVuZFNpbmNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBNYXRoLm1heChNSU5fQ0hFQ0tfSU5URVJWQUwsIHRoaXMucHJvcHMuY2hlY2tJbnRlcnZhbCkgfHwgTUlOX0NIRUNLX0lOVEVSVkFMXG4gICAgKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuZGlzYWJsZVdvcmtlcigpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB0aGlzLnNldFN0YXRlKCh7IHN0YXRlQ29udGV4dCB9KSA9PiAoe1xuICAgICAgc3RhdGVDb250ZXh0OiB7XG4gICAgICAgIC4uLnN0YXRlQ29udGV4dCxcbiAgICAgICAgbW9kZTogbmV4dFByb3BzLm1vZGUgPT09ICd0b3AnID8gJ3RvcCcgOiAnYm90dG9tJ1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGhhbmRsZVNjcm9sbCh7IHRpbWVTdGFtcExvdyB9KSB7XG4gICAgLy8gQ3VycmVudGx5LCB0aGVyZSBhcmUgbm8gcmVsaWFibGUgd2F5IHRvIGNoZWNrIGlmIHRoZSBcInNjcm9sbFwiIGV2ZW50IGlzIHRyaWdnZXIgZHVlIHRvXG4gICAgLy8gdXNlciBnZXN0dXJlLCBwcm9ncmFtbWF0aWMgc2Nyb2xsaW5nLCBvciBDaHJvbWUtc3ludGhlc2l6ZWQgXCJzY3JvbGxcIiBldmVudCB0byBjb21wZW5zYXRlIHNpemUgY2hhbmdlLlxuICAgIC8vIFRodXMsIHdlIHVzZSBvdXIgYmVzdC1lZmZvcnQgdG8gZ3Vlc3MgaWYgaXQgaXMgdHJpZ2dlcmVkIGJ5IHVzZXIgZ2VzdHVyZSwgYW5kIGRpc2FibGUgc3RpY2t5IGlmIGl0IGlzIGhlYWRpbmcgdG93YXJkcyB0aGUgc3RhcnQgZGlyZWN0aW9uLlxuXG4gICAgaWYgKHRpbWVTdGFtcExvdyA8PSB0aGlzLl9pZ25vcmVTY3JvbGxFdmVudEJlZm9yZSkge1xuICAgICAgLy8gU2luY2Ugd2UgZGVib3VuY2UgXCJzY3JvbGxcIiBldmVudCwgdGhpcyBoYW5kbGVyIG1pZ2h0IGJlIGNhbGxlZCBhZnRlciBzcGluZVRvLm9uRW5kIChhLmsuYS4gYXJ0aWZpY2lhbCBzY3JvbGxpbmcpLlxuICAgICAgLy8gV2Ugc2hvdWxkIGlnbm9yZSBkZWJvdW5jZWQgZXZlbnQgZmlyZWQgYWZ0ZXIgc2Nyb2xsRW5kLCBiZWNhdXNlIHdpdGhvdXQgc2tpcHBpbmcgdGhlbSwgdGhlIHVzZXJJbml0aWF0ZWRTY3JvbGwgY2FsY3VsYXRlZCBiZWxvdyB3aWxsIG5vdCBiZSBhY2N1cmF0ZS5cbiAgICAgIC8vIFRodXMsIG9uIGEgZmFzdCBtYWNoaW5lLCBhZGRpbmcgZWxlbWVudHMgc3VwZXIgZmFzdCB3aWxsIGxvc2UgdGhlIFwic3RpY2tpbmVzc1wiLlxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kaXNhYmxlV29ya2VyKCk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlID0+IHtcbiAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBzdGF0ZTtcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc3RhdGVDb250ZXh0IH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBhdEJvdHRvbSwgYXRFbmQsIGF0U3RhcnQsIGF0VG9wIH0gPSBjb21wdXRlVmlld1N0YXRlKHN0YXRlKTtcbiAgICAgICAgbGV0IG5leHRTdGF0ZUNvbnRleHQgPSBzdGF0ZUNvbnRleHQ7XG5cbiAgICAgICAgbmV4dFN0YXRlQ29udGV4dCA9IHVwZGF0ZUluKG5leHRTdGF0ZUNvbnRleHQsIFsnYXRCb3R0b20nXSwgKCkgPT4gYXRCb3R0b20pO1xuICAgICAgICBuZXh0U3RhdGVDb250ZXh0ID0gdXBkYXRlSW4obmV4dFN0YXRlQ29udGV4dCwgWydhdEVuZCddLCAoKSA9PiBhdEVuZCk7XG4gICAgICAgIG5leHRTdGF0ZUNvbnRleHQgPSB1cGRhdGVJbihuZXh0U3RhdGVDb250ZXh0LCBbJ2F0U3RhcnQnXSwgKCkgPT4gYXRTdGFydCk7XG4gICAgICAgIG5leHRTdGF0ZUNvbnRleHQgPSB1cGRhdGVJbihuZXh0U3RhdGVDb250ZXh0LCBbJ2F0VG9wJ10sICgpID0+IGF0VG9wKTtcblxuICAgICAgICAvLyBTdGlja3kgbWVhbnM6XG4gICAgICAgIC8vIC0gSWYgaXQgaXMgc2Nyb2xsZWQgcHJvZ3JhbWF0aWNhbGx5LCB3ZSBhcmUgc3RpbGwgaW4gc3RpY2t5IG1vZGVcbiAgICAgICAgLy8gLSBJZiBpdCBpcyBzY3JvbGxlZCBieSB0aGUgdXNlciwgdGhlbiBzdGlja3kgbWVhbnMgaWYgd2UgYXJlIGF0IHRoZSBlbmRcbiAgICAgICAgbmV4dFN0YXRlQ29udGV4dCA9IHVwZGF0ZUluKG5leHRTdGF0ZUNvbnRleHQsIFsnc3RpY2t5J10sICgpID0+IHN0YXRlQ29udGV4dC5hbmltYXRpbmcgPyB0cnVlIDogYXRFbmQpO1xuXG4gICAgICAgIC8vIElmIG5vIHNjcm9sbFRvcCBpcyBzZXQgKG5vdCBpbiBwcm9ncmFtbWF0aWMgc2Nyb2xsaW5nIG1vZGUpLCB3ZSBzaG91bGQgc2V0IFwiYW5pbWF0aW5nXCIgdG8gZmFsc2VcbiAgICAgICAgLy8gXCJhbmltYXRpbmdcIiBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgXCJzdGlja3lcIiBwcm9wZXJ0eVxuICAgICAgICBpZiAoc2Nyb2xsVG9wID09PSBudWxsKSB7XG4gICAgICAgICAgbmV4dFN0YXRlQ29udGV4dCA9IHVwZGF0ZUluKG5leHRTdGF0ZUNvbnRleHQsIFsnYW5pbWF0aW5nJ10sICgpID0+IGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZUNvbnRleHQgIT09IG5leHRTdGF0ZUNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4geyBzdGF0ZUNvbnRleHQ6IG5leHRTdGF0ZUNvbnRleHQgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUuc3RhdGVDb250ZXh0LnN0aWNreSAmJiB0aGlzLmVuYWJsZVdvcmtlcigpO1xuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlU2Nyb2xsRW5kKCkge1xuICAgIC8vIFdlIHNob3VsZCBpZ25vcmUgZGVib3VuY2luZyBoYW5kbGVTY3JvbGwgdGhhdCBlbWl0IGJlZm9yZSB0aGlzIHRpbWVcbiAgICB0aGlzLl9pZ25vcmVTY3JvbGxFdmVudEJlZm9yZSA9IERhdGUubm93KCk7XG5cbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IHNjcm9sbFRvcDogbnVsbCB9KSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGFuZGxlU2Nyb2xsLFxuICAgICAgaGFuZGxlU2Nyb2xsRW5kLFxuICAgICAgcHJvcHM6IHsgY2hpbGRyZW4sIGRlYm91bmNlIH0sXG4gICAgICBzdGF0ZTogeyBmdW5jdGlvbkNvbnRleHQsIGludGVybmFsQ29udGV4dCwgc2Nyb2xsVG9wLCBzdGF0ZUNvbnRleHQsIHRhcmdldCB9XG4gICAgfSA9IHRoaXM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEludGVybmFsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17IGludGVybmFsQ29udGV4dCB9PlxuICAgICAgICA8RnVuY3Rpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXsgZnVuY3Rpb25Db250ZXh0IH0+XG4gICAgICAgICAgPFN0YXRlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17IHN0YXRlQ29udGV4dCB9PlxuICAgICAgICAgICAgeyBjaGlsZHJlbiB9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRhcmdldCAmJlxuICAgICAgICAgICAgICAgIDxFdmVudFNweVxuICAgICAgICAgICAgICAgICAgZGVib3VuY2U9eyBkZWJvdW5jZSB9XG4gICAgICAgICAgICAgICAgICBuYW1lPVwic2Nyb2xsXCJcbiAgICAgICAgICAgICAgICAgIG9uRXZlbnQ9eyBoYW5kbGVTY3JvbGwgfVxuICAgICAgICAgICAgICAgICAgdGFyZ2V0PXsgdGFyZ2V0IH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0YXJnZXQgJiYgc2Nyb2xsVG9wICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgPFNwaW5lVG9cbiAgICAgICAgICAgICAgICAgIG5hbWU9XCJzY3JvbGxUb3BcIlxuICAgICAgICAgICAgICAgICAgb25FbmQ9eyBoYW5kbGVTY3JvbGxFbmQgfVxuICAgICAgICAgICAgICAgICAgdGFyZ2V0PXsgdGFyZ2V0IH1cbiAgICAgICAgICAgICAgICAgIHZhbHVlPXsgc2Nyb2xsVG9wIH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvU3RhdGVDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L0Z1bmN0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvSW50ZXJuYWxDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG4gIH1cbn1cblxuQ29tcG9zZXIuZGVmYXVsdFByb3BzID0ge1xuICBjaGVja0ludGVydmFsOiAxMDAsXG4gIGRlYm91bmNlOiAxN1xufTtcblxuQ29tcG9zZXIucHJvcFR5cGVzID0ge1xuICBjaGVja0ludGVydmFsOiBQcm9wVHlwZXMubnVtYmVyLFxuICBkZWJvdW5jZTogUHJvcFR5cGVzLm51bWJlclxufTtcbiJdfQ==