{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Exports_1 = require(\"../../common/Exports\");\n\nvar RecognitionEvents_1 = require(\"./RecognitionEvents\");\n\nvar RecognizerConfig_1 = require(\"./RecognizerConfig\");\n\nvar ServiceTelemetryListener_Internal_1 = require(\"./ServiceTelemetryListener.Internal\");\n\nvar SpeechConnectionMessage_Internal_1 = require(\"./SpeechConnectionMessage.Internal\");\n\nvar Recognizer =\n/** @class */\nfunction () {\n  function Recognizer(authentication, connectionFactory, audioSource, recognizerConfig) {\n    var _this = this;\n\n    this.Recognize = function (onEventCallback, speechContextJson) {\n      var requestSession = new RequestSession(_this.audioSource.Id(), onEventCallback);\n      requestSession.ListenForServiceTelemetry(_this.audioSource.Events);\n      return _this.audioSource.Attach(requestSession.AudioNodeId).ContinueWithPromise(function (result) {\n        if (result.IsError) {\n          requestSession.OnAudioSourceAttachCompleted(null, true, result.Error);\n          throw new Error(result.Error);\n        } else {\n          requestSession.OnAudioSourceAttachCompleted(result.Result, false);\n        }\n\n        var audioNode = result.Result;\n\n        _this.FetchConnection(requestSession).OnSuccessContinueWith(function (connection) {\n          var messageRetrievalPromise = _this.ReceiveMessage(connection, requestSession);\n\n          var messageSendPromise = _this.SendSpeechConfig(requestSession.RequestId, connection, _this.recognizerConfig.SpeechConfig.Serialize()).OnSuccessContinueWithPromise(function (_) {\n            return _this.SendSpeechContext(requestSession.RequestId, connection, speechContextJson).OnSuccessContinueWithPromise(function (_) {\n              return _this.SendAudio(requestSession.RequestId, connection, audioNode, requestSession);\n            });\n          });\n\n          var completionPromise = Exports_1.PromiseHelper.WhenAll([messageRetrievalPromise, messageSendPromise]);\n          completionPromise.On(function (r) {\n            requestSession.Dispose();\n\n            _this.SendTelemetryData(requestSession.RequestId, connection, requestSession.GetTelemetry());\n          }, function (error) {\n            requestSession.Dispose(error);\n\n            _this.SendTelemetryData(requestSession.RequestId, connection, requestSession.GetTelemetry());\n          });\n          return completionPromise;\n        });\n\n        return requestSession.CompletionPromise;\n      });\n    };\n\n    this.FetchConnection = function (requestSession, isUnAuthorized) {\n      if (isUnAuthorized === void 0) {\n        isUnAuthorized = false;\n      }\n\n      if (_this.connectionFetchPromise) {\n        if (_this.connectionFetchPromise.Result().IsError || _this.connectionFetchPromise.Result().Result.State() === Exports_1.ConnectionState.Disconnected) {\n          _this.connectionId = null;\n          _this.connectionFetchPromise = null;\n          return _this.FetchConnection(requestSession);\n        } else {\n          requestSession.OnPreConnectionStart(_this.authFetchEventId, _this.connectionId);\n          requestSession.OnConnectionEstablishCompleted(200);\n          requestSession.ListenForServiceTelemetry(_this.connectionFetchPromise.Result().Result.Events);\n          return _this.connectionFetchPromise;\n        }\n      }\n\n      _this.authFetchEventId = Exports_1.CreateNoDashGuid();\n      _this.connectionId = Exports_1.CreateNoDashGuid();\n      requestSession.OnPreConnectionStart(_this.authFetchEventId, _this.connectionId);\n      var authPromise = isUnAuthorized ? _this.authentication.FetchOnExpiry(_this.authFetchEventId) : _this.authentication.Fetch(_this.authFetchEventId);\n      _this.connectionFetchPromise = authPromise.ContinueWithPromise(function (result) {\n        if (result.IsError) {\n          requestSession.OnAuthCompleted(true, result.Error);\n          throw new Error(result.Error);\n        } else {\n          requestSession.OnAuthCompleted(false);\n        }\n\n        var connection = _this.connectionFactory.Create(_this.recognizerConfig, result.Result, _this.connectionId);\n\n        requestSession.ListenForServiceTelemetry(connection.Events);\n        return connection.Open().OnSuccessContinueWithPromise(function (response) {\n          if (response.StatusCode === 200) {\n            requestSession.OnConnectionEstablishCompleted(response.StatusCode);\n            return Exports_1.PromiseHelper.FromResult(connection);\n          } else if (response.StatusCode === 403 && !isUnAuthorized) {\n            return _this.FetchConnection(requestSession, true);\n          } else {\n            requestSession.OnConnectionEstablishCompleted(response.StatusCode, response.Reason);\n            return Exports_1.PromiseHelper.FromError(\"Unable to contact server. StatusCode: \" + response.StatusCode + \", Reason: \" + response.Reason);\n          }\n        });\n      });\n      return _this.connectionFetchPromise;\n    };\n\n    this.ReceiveMessage = function (connection, requestSession) {\n      return connection.Read().OnSuccessContinueWithPromise(function (message) {\n        var connectionMessage = SpeechConnectionMessage_Internal_1.SpeechConnectionMessage.FromConnectionMessage(message);\n\n        if (connectionMessage.RequestId.toLowerCase() === requestSession.RequestId.toLowerCase()) {\n          switch (connectionMessage.Path.toLowerCase()) {\n            case \"turn.start\":\n              requestSession.OnServiceTurnStartResponse(JSON.parse(connectionMessage.TextBody));\n              break;\n\n            case \"speech.startDetected\":\n              requestSession.OnServiceSpeechStartDetectedResponse(JSON.parse(connectionMessage.TextBody));\n              break;\n\n            case \"speech.hypothesis\":\n              requestSession.OnServiceSpeechHypothesisResponse(JSON.parse(connectionMessage.TextBody));\n              break;\n\n            case \"speech.fragment\":\n              requestSession.OnServiceSpeechFragmentResponse(JSON.parse(connectionMessage.TextBody));\n              break;\n\n            case \"speech.enddetected\":\n              requestSession.OnServiceSpeechEndDetectedResponse(JSON.parse(connectionMessage.TextBody));\n              break;\n\n            case \"speech.phrase\":\n              if (_this.recognizerConfig.IsContinuousRecognition) {\n                // For continuous recognition telemetry has to be sent for every phrase as per spec.\n                _this.SendTelemetryData(requestSession.RequestId, connection, requestSession.GetTelemetry());\n              }\n\n              if (_this.recognizerConfig.Format === RecognizerConfig_1.SpeechResultFormat.Simple) {\n                requestSession.OnServiceSimpleSpeechPhraseResponse(JSON.parse(connectionMessage.TextBody));\n              } else {\n                requestSession.OnServiceDetailedSpeechPhraseResponse(JSON.parse(connectionMessage.TextBody));\n              }\n\n              break;\n\n            case \"turn.end\":\n              requestSession.OnServiceTurnEndResponse();\n              return Exports_1.PromiseHelper.FromResult(true);\n\n            default:\n              break;\n          }\n        }\n\n        return _this.ReceiveMessage(connection, requestSession);\n      });\n    };\n\n    this.SendSpeechConfig = function (requestId, connection, speechConfigJson) {\n      if (speechConfigJson && _this.connectionId !== _this.speechConfigConnectionId) {\n        _this.speechConfigConnectionId = _this.connectionId;\n        return connection.Send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_1.MessageType.Text, \"speech.config\", requestId, \"application/json\", speechConfigJson));\n      }\n\n      return Exports_1.PromiseHelper.FromResult(true);\n    };\n\n    this.SendSpeechContext = function (requestId, connection, speechContextJson) {\n      if (speechContextJson) {\n        return connection.Send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_1.MessageType.Text, \"speech.context\", requestId, \"application/json\", speechContextJson));\n      }\n\n      return Exports_1.PromiseHelper.FromResult(true);\n    };\n\n    this.SendTelemetryData = function (requestId, connection, telemetryData) {\n      return connection.Send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_1.MessageType.Text, \"telemetry\", requestId, \"application/json\", telemetryData));\n    };\n\n    this.SendAudio = function (requestId, connection, audioStreamNode, requestSession) {\n      // NOTE: Home-baked promises crash ios safari during the invocation\n      // of the error callback chain (looks like the recursion is way too deep, and\n      // it blows up the stack). The following construct is a stop-gap that does not\n      // bubble the error up the callback chain and hence circumvents this problem.\n      // TODO: rewrite with ES6 promises.\n      var deferred = new Exports_1.Deferred();\n\n      var readAndUploadCycle = function (_) {\n        audioStreamNode.Read().On(function (audioStreamChunk) {\n          // we have a new audio chunk to upload.\n          if (requestSession.IsSpeechEnded) {\n            // If service already recognized audio end then dont send any more audio\n            deferred.Resolve(true);\n            return;\n          }\n\n          var payload = audioStreamChunk.IsEnd ? null : audioStreamChunk.Buffer;\n          var uploaded = connection.Send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_1.MessageType.Binary, \"audio\", requestId, null, payload));\n\n          if (!audioStreamChunk.IsEnd) {\n            uploaded.OnSuccessContinueWith(readAndUploadCycle);\n          } else {\n            // the audio stream has been closed, no need to schedule next\n            // read-upload cycle.\n            deferred.Resolve(true);\n          }\n        }, function (error) {\n          if (requestSession.IsSpeechEnded) {\n            // For whatever reason, Reject is used to remove queue subscribers inside\n            // the Queue.DrainAndDispose invoked from DetachAudioNode down blow, which\n            // means that sometimes things can be rejected in normal circumstances, without\n            // any errors.\n            deferred.Resolve(true); // TODO: remove the argument, it's is completely meaningless.\n          } else {\n            // Only reject, if there was a proper error.\n            deferred.Reject(error);\n          }\n        });\n      };\n\n      readAndUploadCycle(true);\n      return deferred.Promise();\n    };\n\n    if (!authentication) {\n      throw new Exports_1.ArgumentNullError(\"authentication\");\n    }\n\n    if (!connectionFactory) {\n      throw new Exports_1.ArgumentNullError(\"connectionFactory\");\n    }\n\n    if (!audioSource) {\n      throw new Exports_1.ArgumentNullError(\"audioSource\");\n    }\n\n    if (!recognizerConfig) {\n      throw new Exports_1.ArgumentNullError(\"recognizerConfig\");\n    }\n\n    this.authentication = authentication;\n    this.connectionFactory = connectionFactory;\n    this.audioSource = audioSource;\n    this.recognizerConfig = recognizerConfig;\n  }\n\n  Object.defineProperty(Recognizer.prototype, \"AudioSource\", {\n    get: function () {\n      return this.audioSource;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Recognizer;\n}();\n\nexports.Recognizer = Recognizer; // tslint:disable-next-line:max-classes-per-file\n\nvar RequestSession =\n/** @class */\nfunction () {\n  function RequestSession(audioSourceId, onEventCallback) {\n    var _this = this;\n\n    this.isDisposed = false;\n    this.detachables = new Array();\n    this.isAudioNodeDetached = false;\n    this.isCompleted = false;\n\n    this.OnAudioSourceAttachCompleted = function (audioNode, isError, error) {\n      _this.audioNode = audioNode;\n\n      if (isError) {\n        _this.OnComplete(RecognitionEvents_1.RecognitionCompletionStatus.AudioSourceError, error);\n      } else {\n        _this.OnEvent(new RecognitionEvents_1.ListeningStartedEvent(_this.requestId, _this.audioSourceId, _this.audioNodeId));\n      }\n    };\n\n    this.OnPreConnectionStart = function (authFetchEventId, connectionId) {\n      _this.authFetchEventId = authFetchEventId;\n      _this.connectionId = connectionId;\n\n      _this.OnEvent(new RecognitionEvents_1.ConnectingToServiceEvent(_this.requestId, _this.authFetchEventId, _this.connectionId));\n    };\n\n    this.OnAuthCompleted = function (isError, error) {\n      if (isError) {\n        _this.OnComplete(RecognitionEvents_1.RecognitionCompletionStatus.AuthTokenFetchError, error);\n      }\n    };\n\n    this.OnConnectionEstablishCompleted = function (statusCode, reason) {\n      if (statusCode === 200) {\n        _this.OnEvent(new RecognitionEvents_1.RecognitionStartedEvent(_this.RequestId, _this.audioSourceId, _this.audioNodeId, _this.authFetchEventId, _this.connectionId));\n\n        return;\n      } else if (statusCode === 403) {\n        _this.OnComplete(RecognitionEvents_1.RecognitionCompletionStatus.UnAuthorized, reason);\n      } else {\n        _this.OnComplete(RecognitionEvents_1.RecognitionCompletionStatus.ConnectError, reason);\n      }\n    };\n\n    this.OnServiceTurnStartResponse = function (response) {\n      if (response && response.context && response.context.serviceTag) {\n        _this.serviceTag = response.context.serviceTag;\n      }\n    };\n\n    this.OnServiceSpeechStartDetectedResponse = function (result) {\n      _this.OnEvent(new RecognitionEvents_1.SpeechStartDetectedEvent(_this.RequestId, result));\n    };\n\n    this.OnServiceSpeechHypothesisResponse = function (result) {\n      _this.OnEvent(new RecognitionEvents_1.SpeechHypothesisEvent(_this.RequestId, result));\n    };\n\n    this.OnServiceSpeechFragmentResponse = function (result) {\n      _this.OnEvent(new RecognitionEvents_1.SpeechFragmentEvent(_this.RequestId, result));\n    };\n\n    this.OnServiceSpeechEndDetectedResponse = function (result) {\n      _this.DetachAudioNode();\n\n      _this.OnEvent(new RecognitionEvents_1.SpeechEndDetectedEvent(_this.RequestId, result));\n    };\n\n    this.OnServiceSimpleSpeechPhraseResponse = function (result) {\n      _this.OnEvent(new RecognitionEvents_1.SpeechSimplePhraseEvent(_this.RequestId, result));\n    };\n\n    this.OnServiceDetailedSpeechPhraseResponse = function (result) {\n      _this.OnEvent(new RecognitionEvents_1.SpeechDetailedPhraseEvent(_this.RequestId, result));\n    };\n\n    this.OnServiceTurnEndResponse = function () {\n      _this.OnComplete(RecognitionEvents_1.RecognitionCompletionStatus.Success);\n    };\n\n    this.OnConnectionError = function (error) {\n      _this.OnComplete(RecognitionEvents_1.RecognitionCompletionStatus.UnknownError, error);\n    };\n\n    this.Dispose = function (error) {\n      if (!_this.isDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        _this.OnComplete(RecognitionEvents_1.RecognitionCompletionStatus.UnknownError, error);\n\n        _this.isDisposed = true;\n\n        for (var _i = 0, _a = _this.detachables; _i < _a.length; _i++) {\n          var detachable = _a[_i];\n          detachable.Detach();\n        }\n\n        _this.serviceTelemetryListener.Dispose();\n      }\n    };\n\n    this.GetTelemetry = function () {\n      return _this.serviceTelemetryListener.GetTelemetry();\n    };\n\n    this.OnComplete = function (status, error) {\n      if (!_this.isCompleted) {\n        _this.isCompleted = true;\n\n        _this.DetachAudioNode();\n\n        _this.OnEvent(new RecognitionEvents_1.RecognitionEndedEvent(_this.RequestId, _this.audioSourceId, _this.audioNodeId, _this.authFetchEventId, _this.connectionId, _this.serviceTag, status, error ? error : \"\"));\n      }\n    };\n\n    this.DetachAudioNode = function () {\n      if (!_this.isAudioNodeDetached) {\n        _this.isAudioNodeDetached = true;\n\n        if (_this.audioNode) {\n          _this.audioNode.Detach();\n        }\n      }\n    };\n\n    this.OnEvent = function (event) {\n      _this.serviceTelemetryListener.OnEvent(event);\n\n      Exports_1.Events.Instance.OnEvent(event);\n\n      if (_this.onEventCallback) {\n        _this.onEventCallback(event);\n      }\n    };\n\n    this.audioSourceId = audioSourceId;\n    this.onEventCallback = onEventCallback;\n    this.requestId = Exports_1.CreateNoDashGuid();\n    this.audioNodeId = Exports_1.CreateNoDashGuid();\n    this.requestCompletionDeferral = new Exports_1.Deferred();\n    this.serviceTelemetryListener = new ServiceTelemetryListener_Internal_1.ServiceTelemetryListener(this.requestId, this.audioSourceId, this.audioNodeId);\n    this.OnEvent(new RecognitionEvents_1.RecognitionTriggeredEvent(this.RequestId, this.audioSourceId, this.audioNodeId));\n  }\n\n  Object.defineProperty(RequestSession.prototype, \"RequestId\", {\n    get: function () {\n      return this.requestId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"AudioNodeId\", {\n    get: function () {\n      return this.audioNodeId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"CompletionPromise\", {\n    get: function () {\n      return this.requestCompletionDeferral.Promise();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"IsSpeechEnded\", {\n    get: function () {\n      return this.isAudioNodeDetached;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"IsCompleted\", {\n    get: function () {\n      return this.isCompleted;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  RequestSession.prototype.ListenForServiceTelemetry = function (eventSource) {\n    this.detachables.push(eventSource.AttachListener(this.serviceTelemetryListener));\n  };\n\n  return RequestSession;\n}();","map":null,"metadata":{},"sourceType":"script"}