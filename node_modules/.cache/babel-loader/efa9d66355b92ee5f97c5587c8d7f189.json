{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _reactDictateButton = require(\"react-dictate-button\");\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _botframeworkWebchatCore = require(\"botframework-webchat-core\");\n\nvar _connectToWebChat = _interopRequireDefault(require(\"./connectToWebChat\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar _Constants$DictateSta = _botframeworkWebchatCore.Constants.DictateState,\n    DICTATING = _Constants$DictateSta.DICTATING,\n    IDLE = _Constants$DictateSta.IDLE,\n    STARTING = _Constants$DictateSta.STARTING;\n\nvar Dictation =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Dictation, _React$Component);\n\n  function Dictation(props) {\n    var _this;\n\n    _classCallCheck(this, Dictation);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Dictation).call(this, props));\n    _this.handleDictate = _this.handleDictate.bind(_assertThisInitialized(_this));\n    _this.handleDictating = _this.handleDictating.bind(_assertThisInitialized(_this));\n    _this.handleError = _this.handleError.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Dictation, [{\n    key: \"handleDictate\",\n    value: function handleDictate(_ref) {\n      var _ref$result = _ref.result;\n      _ref$result = _ref$result === void 0 ? {} : _ref$result;\n      var transcript = _ref$result.transcript;\n      var props = this.props;\n      props.setDictateInterims([]);\n      props.setDictateState(IDLE);\n      props.stopDictate();\n\n      if (transcript) {\n        props.setSendBox(transcript);\n        props.submitSendBox('speech');\n        props.startSpeakingActivity();\n      }\n    }\n  }, {\n    key: \"handleDictating\",\n    value: function handleDictating(_ref2) {\n      var _ref2$results = _ref2.results,\n          results = _ref2$results === void 0 ? [] : _ref2$results;\n      var props = this.props;\n      var interims = results.map(function (_ref3) {\n        var transcript = _ref3.transcript;\n        return transcript;\n      });\n      props.setDictateInterims(interims);\n      props.setDictateState(DICTATING); // This is for two purposes:\n      // 1. Set send box will also trigger send typing\n      // 2. If the user cancelled out, the interim result will be in the send box so the user can update it before send\n\n      props.setSendBox(interims.join(' '));\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(event) {\n      var props = this.props;\n      props.setDictateState(IDLE);\n      props.stopDictate();\n      props.onError && props.onError(event);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          dictateState = _this$props.dictateState,\n          disabled = _this$props.disabled,\n          language = _this$props.language,\n          webSpeechPonyfill = _this$props.webSpeechPonyfill,\n          handleDictate = this.handleDictate,\n          handleDictating = this.handleDictating,\n          handleError = this.handleError;\n\n      var _ref4 = webSpeechPonyfill || {},\n          SpeechGrammarList = _ref4.SpeechGrammarList,\n          SpeechRecognition = _ref4.SpeechRecognition;\n\n      return _react.default.createElement(_reactDictateButton.Composer, {\n        lang: language,\n        onDictate: handleDictate,\n        onError: handleError,\n        onProgress: handleDictating,\n        speechRecognition: SpeechRecognition,\n        speechGrammarList: SpeechGrammarList,\n        started: !disabled && (dictateState === STARTING || dictateState === DICTATING)\n      });\n    }\n  }]);\n\n  return Dictation;\n}(_react.default.Component);\n\nvar _default = (0, _connectToWebChat.default)(function (_ref5) {\n  var dictateState = _ref5.dictateState,\n      disabled = _ref5.disabled,\n      language = _ref5.language,\n      setDictateInterims = _ref5.setDictateInterims,\n      setDictateState = _ref5.setDictateState,\n      setSendBox = _ref5.setSendBox,\n      startSpeakingActivity = _ref5.startSpeakingActivity,\n      stopDictate = _ref5.stopDictate,\n      submitSendBox = _ref5.submitSendBox,\n      webSpeechPonyfill = _ref5.webSpeechPonyfill;\n  return {\n    dictateState: dictateState,\n    disabled: disabled,\n    language: language,\n    setDictateInterims: setDictateInterims,\n    setDictateState: setDictateState,\n    setSendBox: setSendBox,\n    startSpeakingActivity: startSpeakingActivity,\n    stopDictate: stopDictate,\n    submitSendBox: submitSendBox,\n    webSpeechPonyfill: webSpeechPonyfill\n  };\n})(Dictation);\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}