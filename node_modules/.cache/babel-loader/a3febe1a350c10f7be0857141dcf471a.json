{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectLine = exports.ConnectionStatus = void 0;\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _BehaviorSubject = require(\"rxjs/BehaviorSubject\");\n\nvar _Observable = require(\"rxjs/Observable\");\n\nrequire(\"rxjs/add/operator/catch\");\n\nrequire(\"rxjs/add/operator/combineLatest\");\n\nrequire(\"rxjs/add/operator/count\");\n\nrequire(\"rxjs/add/operator/delay\");\n\nrequire(\"rxjs/add/operator/do\");\n\nrequire(\"rxjs/add/operator/filter\");\n\nrequire(\"rxjs/add/operator/map\");\n\nrequire(\"rxjs/add/operator/mergeMap\");\n\nrequire(\"rxjs/add/operator/retryWhen\");\n\nrequire(\"rxjs/add/operator/share\");\n\nrequire(\"rxjs/add/operator/take\");\n\nrequire(\"rxjs/add/observable/dom/ajax\");\n\nrequire(\"rxjs/add/observable/empty\");\n\nrequire(\"rxjs/add/observable/from\");\n\nrequire(\"rxjs/add/observable/interval\");\n\nrequire(\"rxjs/add/observable/of\");\n\nrequire(\"rxjs/add/observable/throw\"); // In order to keep file size down, only import the parts of rxjs that we use\n\n\nvar DIRECT_LINE_VERSION = 'DirectLine/3.0'; // These types are specific to this client library, not to Direct Line 3.0\n\nvar ConnectionStatus;\nexports.ConnectionStatus = ConnectionStatus;\n\n(function (ConnectionStatus) {\n  ConnectionStatus[ConnectionStatus[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  ConnectionStatus[ConnectionStatus[\"Connecting\"] = 1] = \"Connecting\";\n  ConnectionStatus[ConnectionStatus[\"Online\"] = 2] = \"Online\";\n  ConnectionStatus[ConnectionStatus[\"ExpiredToken\"] = 3] = \"ExpiredToken\";\n  ConnectionStatus[ConnectionStatus[\"FailedToConnect\"] = 4] = \"FailedToConnect\";\n  ConnectionStatus[ConnectionStatus[\"Ended\"] = 5] = \"Ended\";\n})(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));\n\nvar lifetimeRefreshToken = 30 * 60 * 1000;\nvar intervalRefreshToken = lifetimeRefreshToken / 2;\nvar timeout = 20 * 1000;\nvar retries = (lifetimeRefreshToken - intervalRefreshToken) / timeout;\nvar POLLING_INTERVAL_LOWER_BOUND = 200; //ms\n\nvar errorExpiredToken = new Error(\"expired token\");\nvar errorConversationEnded = new Error(\"conversation ended\");\nvar errorFailedToConnect = new Error(\"failed to connect\");\nvar konsole = {\n  log: function log(message) {\n    var _console;\n\n    for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      optionalParams[_key - 1] = arguments[_key];\n    }\n\n    if (typeof window !== 'undefined' && window[\"botchatDebug\"] && message) (_console = console).log.apply(_console, [message].concat(optionalParams));\n  }\n};\n\nvar DirectLine =\n/*#__PURE__*/\nfunction () {\n  //ms\n  function DirectLine(options) {\n    (0, _classCallCheck2.default)(this, DirectLine);\n    (0, _defineProperty2.default)(this, \"connectionStatus$\", new _BehaviorSubject.BehaviorSubject(ConnectionStatus.Uninitialized));\n    (0, _defineProperty2.default)(this, \"activity$\", void 0);\n    (0, _defineProperty2.default)(this, \"domain\", \"https://directline.botframework.com/v3/directline\");\n    (0, _defineProperty2.default)(this, \"webSocket\", void 0);\n    (0, _defineProperty2.default)(this, \"conversationId\", void 0);\n    (0, _defineProperty2.default)(this, \"expiredTokenExhaustion\", void 0);\n    (0, _defineProperty2.default)(this, \"secret\", void 0);\n    (0, _defineProperty2.default)(this, \"token\", void 0);\n    (0, _defineProperty2.default)(this, \"watermark\", '');\n    (0, _defineProperty2.default)(this, \"streamUrl\", void 0);\n    (0, _defineProperty2.default)(this, \"_botAgent\", '');\n    (0, _defineProperty2.default)(this, \"_userAgent\", void 0);\n    (0, _defineProperty2.default)(this, \"referenceGrammarId\", void 0);\n    (0, _defineProperty2.default)(this, \"pollingInterval\", 1000);\n    (0, _defineProperty2.default)(this, \"tokenRefreshSubscription\", void 0);\n    this.secret = options.secret;\n    this.token = options.secret || options.token;\n    this.webSocket = (options.webSocket === undefined ? true : options.webSocket) && typeof WebSocket !== 'undefined' && WebSocket !== undefined;\n\n    if (options.domain) {\n      this.domain = options.domain;\n    }\n\n    if (options.conversationId) {\n      this.conversationId = options.conversationId;\n    }\n\n    if (options.watermark) {\n      this.watermark = options.watermark;\n    }\n\n    if (options.streamUrl) {\n      if (options.token && options.conversationId) {\n        this.streamUrl = options.streamUrl;\n      } else {\n        console.warn('DirectLineJS: streamUrl was ignored: you need to provide a token and a conversationid');\n      }\n    }\n\n    this._botAgent = this.getBotAgent(options.botAgent);\n    var parsedPollingInterval = ~~options.pollingInterval;\n\n    if (parsedPollingInterval < POLLING_INTERVAL_LOWER_BOUND) {\n      if (typeof options.pollingInterval !== 'undefined') {\n        console.warn(\"DirectLineJS: provided pollingInterval (\".concat(options.pollingInterval, \") is under lower bound (200ms), using default of 1000ms\"));\n      }\n    } else {\n      this.pollingInterval = parsedPollingInterval;\n    }\n\n    this.expiredTokenExhaustion = this.setConnectionStatusFallback(ConnectionStatus.ExpiredToken, ConnectionStatus.FailedToConnect, 5);\n    this.activity$ = (this.webSocket ? this.webSocketActivity$() : this.pollingGetActivity$()).share();\n  } // Every time we're about to make a Direct Line REST call, we call this first to see check the current connection status.\n  // Either throws an error (indicating an error state) or emits a null, indicating a (presumably) healthy connection\n\n\n  (0, _createClass2.default)(DirectLine, [{\n    key: \"checkConnection\",\n    value: function checkConnection() {\n      var _this = this;\n\n      var once = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var obs = this.connectionStatus$.flatMap(function (connectionStatus) {\n        if (connectionStatus === ConnectionStatus.Uninitialized) {\n          _this.connectionStatus$.next(ConnectionStatus.Connecting); //if token and streamUrl are defined it means reconnect has already been done. Skipping it.\n\n\n          if (_this.token && _this.streamUrl) {\n            _this.connectionStatus$.next(ConnectionStatus.Online);\n\n            return _Observable.Observable.of(connectionStatus);\n          } else {\n            return _this.startConversation().do(function (conversation) {\n              _this.conversationId = conversation.conversationId;\n              _this.token = _this.secret || conversation.token;\n              _this.streamUrl = conversation.streamUrl;\n              _this.referenceGrammarId = conversation.referenceGrammarId;\n              if (!_this.secret) _this.refreshTokenLoop();\n\n              _this.connectionStatus$.next(ConnectionStatus.Online);\n            }, function (error) {\n              _this.connectionStatus$.next(ConnectionStatus.FailedToConnect);\n            }).map(function (_) {\n              return connectionStatus;\n            });\n          }\n        } else {\n          return _Observable.Observable.of(connectionStatus);\n        }\n      }).filter(function (connectionStatus) {\n        return connectionStatus != ConnectionStatus.Uninitialized && connectionStatus != ConnectionStatus.Connecting;\n      }).flatMap(function (connectionStatus) {\n        switch (connectionStatus) {\n          case ConnectionStatus.Ended:\n            return _Observable.Observable.throw(errorConversationEnded);\n\n          case ConnectionStatus.FailedToConnect:\n            return _Observable.Observable.throw(errorFailedToConnect);\n\n          case ConnectionStatus.ExpiredToken:\n            return _Observable.Observable.of(connectionStatus);\n\n          default:\n            return _Observable.Observable.of(connectionStatus);\n        }\n      });\n      return once ? obs.take(1) : obs;\n    }\n  }, {\n    key: \"setConnectionStatusFallback\",\n    value: function setConnectionStatusFallback(connectionStatusFrom, connectionStatusTo) {\n      var maxAttempts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n      maxAttempts--;\n      var attempts = 0;\n      var currStatus = null;\n      return function (status) {\n        if (status === connectionStatusFrom && currStatus === status && attempts >= maxAttempts) {\n          attempts = 0;\n          return connectionStatusTo;\n        }\n\n        attempts++;\n        currStatus = status;\n        return status;\n      };\n    }\n  }, {\n    key: \"expiredToken\",\n    value: function expiredToken() {\n      var connectionStatus = this.connectionStatus$.getValue();\n      if (connectionStatus != ConnectionStatus.Ended && connectionStatus != ConnectionStatus.FailedToConnect) this.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n      var protectedConnectionStatus = this.expiredTokenExhaustion(this.connectionStatus$.getValue());\n      this.connectionStatus$.next(protectedConnectionStatus);\n    }\n  }, {\n    key: \"startConversation\",\n    value: function startConversation() {\n      //if conversationid is set here, it means we need to call the reconnect api, else it is a new conversation\n      var url = this.conversationId ? \"\".concat(this.domain, \"/conversations/\").concat(this.conversationId, \"?watermark=\").concat(this.watermark) : \"\".concat(this.domain, \"/conversations\");\n      var method = this.conversationId ? \"GET\" : \"POST\";\n      return _Observable.Observable.ajax({\n        method: method,\n        url: url,\n        timeout: timeout,\n        headers: (0, _objectSpread2.default)({\n          \"Accept\": \"application/json\"\n        }, this.commonHeaders())\n      }) //      .do(ajaxResponse => konsole.log(\"conversation ajaxResponse\", ajaxResponse.response))\n      .map(function (ajaxResponse) {\n        return ajaxResponse.response;\n      }).retryWhen(function (error$) {\n        return (// for now we deem 4xx and 5xx errors as unrecoverable\n          // for everything else (timeouts), retry for a while\n          error$.mergeMap(function (error) {\n            return error.status >= 400 && error.status < 600 ? _Observable.Observable.throw(error) : _Observable.Observable.of(error);\n          }).delay(timeout).take(retries)\n        );\n      });\n    }\n  }, {\n    key: \"refreshTokenLoop\",\n    value: function refreshTokenLoop() {\n      var _this2 = this;\n\n      this.tokenRefreshSubscription = _Observable.Observable.interval(intervalRefreshToken).flatMap(function (_) {\n        return _this2.refreshToken();\n      }).subscribe(function (token) {\n        konsole.log(\"refreshing token\", token, \"at\", new Date());\n        _this2.token = token;\n      });\n    }\n  }, {\n    key: \"refreshToken\",\n    value: function refreshToken() {\n      var _this3 = this;\n\n      return this.checkConnection(true).flatMap(function (_) {\n        return _Observable.Observable.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this3.domain, \"/tokens/refresh\"),\n          timeout: timeout,\n          headers: (0, _objectSpread2.default)({}, _this3.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.token;\n        }).retryWhen(function (error$) {\n          return error$.mergeMap(function (error) {\n            if (error.status === 403) {\n              // if the token is expired there's no reason to keep trying\n              _this3.expiredToken();\n\n              return _Observable.Observable.throw(error);\n            } else if (error.status === 404) {\n              // If the bot is gone, we should stop retrying\n              return _Observable.Observable.throw(error);\n            }\n\n            return _Observable.Observable.of(error);\n          }).delay(timeout).take(retries);\n        });\n      });\n    }\n  }, {\n    key: \"reconnect\",\n    value: function reconnect(conversation) {\n      this.token = conversation.token;\n      this.streamUrl = conversation.streamUrl;\n      if (this.connectionStatus$.getValue() === ConnectionStatus.ExpiredToken) this.connectionStatus$.next(ConnectionStatus.Online);\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this.tokenRefreshSubscription) this.tokenRefreshSubscription.unsubscribe();\n\n      try {\n        this.connectionStatus$.next(ConnectionStatus.Ended);\n      } catch (e) {\n        if (e === errorConversationEnded) return;\n        throw e;\n      }\n    }\n  }, {\n    key: \"getSessionId\",\n    value: function getSessionId() {\n      var _this4 = this; // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n\n\n      konsole.log(\"getSessionId\");\n      return this.checkConnection(true).flatMap(function (_) {\n        return _Observable.Observable.ajax({\n          method: \"GET\",\n          url: \"\".concat(_this4.domain, \"/session/getsessionid\"),\n          withCredentials: true,\n          timeout: timeout,\n          headers: (0, _objectSpread2.default)({\n            \"Content-Type\": \"application/json\"\n          }, _this4.commonHeaders())\n        }).map(function (ajaxResponse) {\n          if (ajaxResponse && ajaxResponse.response && ajaxResponse.response.sessionId) {\n            konsole.log(\"getSessionId response: \" + ajaxResponse.response.sessionId);\n            return ajaxResponse.response.sessionId;\n          }\n\n          return '';\n        }).catch(function (error) {\n          konsole.log(\"getSessionId error: \" + error.status);\n          return _Observable.Observable.of('');\n        });\n      }).catch(function (error) {\n        return _this4.catchExpiredToken(error);\n      });\n    }\n  }, {\n    key: \"postActivity\",\n    value: function postActivity(activity) {\n      var _this5 = this; // Use postMessageWithAttachments for messages with attachments that are local files (e.g. an image to upload)\n      // Technically we could use it for *all* activities, but postActivity is much lighter weight\n      // So, since WebChat is partially a reference implementation of Direct Line, we implement both.\n\n\n      if (activity.type === \"message\" && activity.attachments && activity.attachments.length > 0) return this.postMessageWithAttachments(activity); // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n\n      konsole.log(\"postActivity\", activity);\n      return this.checkConnection(true).flatMap(function (_) {\n        return _Observable.Observable.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this5.domain, \"/conversations/\").concat(_this5.conversationId, \"/activities\"),\n          body: activity,\n          timeout: timeout,\n          headers: (0, _objectSpread2.default)({\n            \"Content-Type\": \"application/json\"\n          }, _this5.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.id;\n        }).catch(function (error) {\n          return _this5.catchPostError(error);\n        });\n      }).catch(function (error) {\n        return _this5.catchExpiredToken(error);\n      });\n    }\n  }, {\n    key: \"postMessageWithAttachments\",\n    value: function postMessageWithAttachments(_ref) {\n      var _this6 = this;\n\n      var attachments = _ref.attachments,\n          messageWithoutAttachments = (0, _objectWithoutProperties2.default)(_ref, [\"attachments\"]);\n      var formData; // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n\n      return this.checkConnection(true).flatMap(function (_) {\n        // To send this message to DirectLine we need to deconstruct it into a \"template\" activity\n        // and one blob for each attachment.\n        formData = new FormData();\n        formData.append('activity', new Blob([JSON.stringify(messageWithoutAttachments)], {\n          type: 'application/vnd.microsoft.activity'\n        }));\n        return _Observable.Observable.from(attachments || []).flatMap(function (media) {\n          return _Observable.Observable.ajax({\n            method: \"GET\",\n            url: media.contentUrl,\n            responseType: 'arraybuffer'\n          }).do(function (ajaxResponse) {\n            return formData.append('file', new Blob([ajaxResponse.response], {\n              type: media.contentType\n            }), media.name);\n          });\n        }).count();\n      }).flatMap(function (_) {\n        return _Observable.Observable.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this6.domain, \"/conversations/\").concat(_this6.conversationId, \"/upload?userId=\").concat(messageWithoutAttachments.from.id),\n          body: formData,\n          timeout: timeout,\n          headers: (0, _objectSpread2.default)({}, _this6.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.id;\n        }).catch(function (error) {\n          return _this6.catchPostError(error);\n        });\n      }).catch(function (error) {\n        return _this6.catchPostError(error);\n      });\n    }\n  }, {\n    key: \"catchPostError\",\n    value: function catchPostError(error) {\n      if (error.status === 403) // token has expired (will fall through to return \"retry\")\n        this.expiredToken();else if (error.status >= 400 && error.status < 500) // more unrecoverable errors\n        return _Observable.Observable.throw(error);\n      return _Observable.Observable.of(\"retry\");\n    }\n  }, {\n    key: \"catchExpiredToken\",\n    value: function catchExpiredToken(error) {\n      return error === errorExpiredToken ? _Observable.Observable.of(\"retry\") : _Observable.Observable.throw(error);\n    }\n  }, {\n    key: \"pollingGetActivity$\",\n    value: function pollingGetActivity$() {\n      var _this7 = this;\n\n      var poller$ = _Observable.Observable.create(function (subscriber) {\n        // A BehaviorSubject to trigger polling. Since it is a BehaviorSubject\n        // the first event is produced immediately.\n        var trigger$ = new _BehaviorSubject.BehaviorSubject({});\n        trigger$.subscribe(function () {\n          if (_this7.connectionStatus$.getValue() === ConnectionStatus.Online) {\n            var startTimestamp = Date.now();\n\n            _Observable.Observable.ajax({\n              headers: (0, _objectSpread2.default)({\n                Accept: 'application/json'\n              }, _this7.commonHeaders()),\n              method: 'GET',\n              url: \"\".concat(_this7.domain, \"/conversations/\").concat(_this7.conversationId, \"/activities?watermark=\").concat(_this7.watermark),\n              timeout: timeout\n            }).subscribe(function (result) {\n              subscriber.next(result);\n              setTimeout(function () {\n                return trigger$.next(null);\n              }, Math.max(0, _this7.pollingInterval - Date.now() + startTimestamp));\n            }, function (error) {\n              switch (error.status) {\n                case 403:\n                  _this7.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n\n                  setTimeout(function () {\n                    return trigger$.next(null);\n                  }, _this7.pollingInterval);\n                  break;\n\n                case 404:\n                  _this7.connectionStatus$.next(ConnectionStatus.Ended);\n\n                  break;\n\n                default:\n                  // propagate the error\n                  subscriber.error(error);\n                  break;\n              }\n            });\n          }\n        });\n      });\n\n      return this.checkConnection().flatMap(function (_) {\n        return poller$.catch(function () {\n          return _Observable.Observable.empty();\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response;\n        }).flatMap(function (activityGroup) {\n          return _this7.observableFromActivityGroup(activityGroup);\n        });\n      });\n    }\n  }, {\n    key: \"observableFromActivityGroup\",\n    value: function observableFromActivityGroup(activityGroup) {\n      if (activityGroup.watermark) this.watermark = activityGroup.watermark;\n      return _Observable.Observable.from(activityGroup.activities);\n    }\n  }, {\n    key: \"webSocketActivity$\",\n    value: function webSocketActivity$() {\n      var _this8 = this;\n\n      return this.checkConnection().flatMap(function (_) {\n        return _this8.observableWebSocket() // WebSockets can be closed by the server or the browser. In the former case we need to\n        // retrieve a new streamUrl. In the latter case we could first retry with the current streamUrl,\n        // but it's simpler just to always fetch a new one.\n        .retryWhen(function (error$) {\n          return error$.delay(_this8.getRetryDelay()).mergeMap(function (error) {\n            return _this8.reconnectToConversation();\n          });\n        });\n      }).flatMap(function (activityGroup) {\n        return _this8.observableFromActivityGroup(activityGroup);\n      });\n    } // Returns the delay duration in milliseconds\n\n  }, {\n    key: \"getRetryDelay\",\n    value: function getRetryDelay() {\n      return Math.floor(3000 + Math.random() * 12000);\n    } // Originally we used Observable.webSocket, but it's fairly opionated  and I ended up writing\n    // a lot of code to work around their implemention details. Since WebChat is meant to be a reference\n    // implementation, I decided roll the below, where the logic is more purposeful. - @billba\n\n  }, {\n    key: \"observableWebSocket\",\n    value: function observableWebSocket() {\n      var _this9 = this;\n\n      return _Observable.Observable.create(function (subscriber) {\n        konsole.log(\"creating WebSocket\", _this9.streamUrl);\n        var ws = new WebSocket(_this9.streamUrl);\n        var sub;\n\n        ws.onopen = function (open) {\n          konsole.log(\"WebSocket open\", open); // Chrome is pretty bad at noticing when a WebSocket connection is broken.\n          // If we periodically ping the server with empty messages, it helps Chrome\n          // realize when connection breaks, and close the socket. We then throw an\n          // error, and that give us the opportunity to attempt to reconnect.\n\n          sub = _Observable.Observable.interval(timeout).subscribe(function (_) {\n            try {\n              ws.send(\"\");\n            } catch (e) {\n              konsole.log(\"Ping error\", e);\n            }\n          });\n        };\n\n        ws.onclose = function (close) {\n          konsole.log(\"WebSocket close\", close);\n          if (sub) sub.unsubscribe();\n          subscriber.error(close);\n        };\n\n        ws.onmessage = function (message) {\n          return message.data && subscriber.next(JSON.parse(message.data));\n        }; // This is the 'unsubscribe' method, which is called when this observable is disposed.\n        // When the WebSocket closes itself, we throw an error, and this function is eventually called.\n        // When the observable is closed first (e.g. when tearing down a WebChat instance) then\n        // we need to manually close the WebSocket.\n\n\n        return function () {\n          if (ws.readyState === 0 || ws.readyState === 1) ws.close();\n        };\n      });\n    }\n  }, {\n    key: \"reconnectToConversation\",\n    value: function reconnectToConversation() {\n      var _this10 = this;\n\n      return this.checkConnection(true).flatMap(function (_) {\n        return _Observable.Observable.ajax({\n          method: \"GET\",\n          url: \"\".concat(_this10.domain, \"/conversations/\").concat(_this10.conversationId, \"?watermark=\").concat(_this10.watermark),\n          timeout: timeout,\n          headers: (0, _objectSpread2.default)({\n            \"Accept\": \"application/json\"\n          }, _this10.commonHeaders())\n        }).do(function (result) {\n          if (!_this10.secret) _this10.token = result.response.token;\n          _this10.streamUrl = result.response.streamUrl;\n        }).map(function (_) {\n          return null;\n        }).retryWhen(function (error$) {\n          return error$.mergeMap(function (error) {\n            if (error.status === 403) {\n              // token has expired. We can't recover from this here, but the embedding\n              // website might eventually call reconnect() with a new token and streamUrl.\n              _this10.expiredToken();\n            } else if (error.status === 404) {\n              return _Observable.Observable.throw(errorConversationEnded);\n            }\n\n            return _Observable.Observable.of(error);\n          }).delay(timeout).take(retries);\n        });\n      });\n    }\n  }, {\n    key: \"commonHeaders\",\n    value: function commonHeaders() {\n      return {\n        \"Authorization\": \"Bearer \".concat(this.token),\n        \"x-ms-bot-agent\": this._botAgent\n      };\n    }\n  }, {\n    key: \"getBotAgent\",\n    value: function getBotAgent() {\n      var customAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var clientAgent = 'directlinejs';\n\n      if (customAgent) {\n        clientAgent += \"; \".concat(customAgent);\n      }\n\n      return \"\".concat(DIRECT_LINE_VERSION, \" (\").concat(clientAgent, \")\");\n    }\n  }]);\n  return DirectLine;\n}();\n\nexports.DirectLine = DirectLine;","map":null,"metadata":{},"sourceType":"script"}