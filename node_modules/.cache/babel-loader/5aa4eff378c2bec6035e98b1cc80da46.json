{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Exports_1 = require(\"../common/Exports\");\n\nvar Exports_2 = require(\"../common.browser/Exports\");\n\nvar FileAudioSource =\n/** @class */\nfunction () {\n  function FileAudioSource(file, audioSourceId) {\n    var _this = this;\n\n    this.streams = {};\n\n    this.TurnOn = function () {\n      if (typeof FileReader === \"undefined\") {\n        var errorMsg = \"Browser does not support FileReader.\";\n\n        _this.OnEvent(new Exports_1.AudioSourceErrorEvent(errorMsg, \"\")); // initialization error - no streamid at this point\n\n\n        return Exports_1.PromiseHelper.FromError(errorMsg);\n      } else if (_this.file.name.lastIndexOf(\".wav\") !== _this.file.name.length - 4) {\n        var errorMsg = _this.file.name + \" is not supported. Only WAVE files are allowed at the moment.\";\n\n        _this.OnEvent(new Exports_1.AudioSourceErrorEvent(errorMsg, \"\"));\n\n        return Exports_1.PromiseHelper.FromError(errorMsg);\n      } else if (_this.file.size > FileAudioSource.MAX_SIZE) {\n        var errorMsg = _this.file.name + \" exceeds the maximum allowed file size (\" + FileAudioSource.MAX_SIZE + \").\";\n\n        _this.OnEvent(new Exports_1.AudioSourceErrorEvent(errorMsg, \"\"));\n\n        return Exports_1.PromiseHelper.FromError(errorMsg);\n      }\n\n      _this.OnEvent(new Exports_1.AudioSourceInitializingEvent(_this.id)); // no stream id\n\n\n      _this.OnEvent(new Exports_1.AudioSourceReadyEvent(_this.id));\n\n      return Exports_1.PromiseHelper.FromResult(true);\n    };\n\n    this.Id = function () {\n      return _this.id;\n    };\n\n    this.Attach = function (audioNodeId) {\n      _this.OnEvent(new Exports_1.AudioStreamNodeAttachingEvent(_this.id, audioNodeId));\n\n      return _this.Upload(audioNodeId).OnSuccessContinueWith(function (streamReader) {\n        _this.OnEvent(new Exports_1.AudioStreamNodeAttachedEvent(_this.id, audioNodeId));\n\n        return {\n          Detach: function () {\n            streamReader.Close();\n            delete _this.streams[audioNodeId];\n\n            _this.OnEvent(new Exports_1.AudioStreamNodeDetachedEvent(_this.id, audioNodeId));\n\n            _this.TurnOff();\n          },\n          Id: function () {\n            return audioNodeId;\n          },\n          Read: function () {\n            return streamReader.Read();\n          }\n        };\n      });\n    };\n\n    this.Detach = function (audioNodeId) {\n      if (audioNodeId && _this.streams[audioNodeId]) {\n        _this.streams[audioNodeId].Close();\n\n        delete _this.streams[audioNodeId];\n\n        _this.OnEvent(new Exports_1.AudioStreamNodeDetachedEvent(_this.id, audioNodeId));\n      }\n    };\n\n    this.TurnOff = function () {\n      for (var streamId in _this.streams) {\n        if (streamId) {\n          var stream = _this.streams[streamId];\n\n          if (stream && !stream.IsClosed) {\n            stream.Close();\n          }\n        }\n      }\n\n      _this.OnEvent(new Exports_1.AudioSourceOffEvent(_this.id)); // no stream now\n\n\n      return Exports_1.PromiseHelper.FromResult(true);\n    };\n\n    this.Upload = function (audioNodeId) {\n      return _this.TurnOn().OnSuccessContinueWith(function (_) {\n        var stream = new Exports_1.Stream(audioNodeId);\n        _this.streams[audioNodeId] = stream;\n        var reader = new FileReader();\n        var startOffset = 0;\n        var endOffset = FileAudioSource.CHUNK_SIZE;\n        var lastWriteTimestamp = 0;\n\n        var processNextChunk = function (event) {\n          if (stream.IsClosed) {\n            return; // output stream was closed (somebody called TurnOff). We're done here.\n          }\n\n          if (lastWriteTimestamp !== 0) {\n            var delay = Date.now() - lastWriteTimestamp;\n\n            if (delay < FileAudioSource.UPLOAD_INTERVAL) {\n              // It's been less than the \"upload interval\" since we've uploaded the\n              // last chunk. Schedule the next upload to make sure that we're sending\n              // upstream roughly one chunk per upload interval.\n              new Exports_2.Timer(FileAudioSource.UPLOAD_INTERVAL - delay, processNextChunk).start();\n              return;\n            }\n          }\n\n          stream.Write(reader.result);\n          lastWriteTimestamp = Date.now();\n\n          if (endOffset < _this.file.size) {\n            startOffset = endOffset;\n            endOffset = Math.min(endOffset + FileAudioSource.CHUNK_SIZE, _this.file.size);\n\n            var chunk_1 = _this.file.slice(startOffset, endOffset);\n\n            reader.readAsArrayBuffer(chunk_1);\n          } else {\n            // we've written the entire file to the output stream, can close it now.\n            stream.Close();\n          }\n        };\n\n        reader.onload = processNextChunk;\n\n        reader.onerror = function (event) {\n          var errorMsg = \"Error occurred while processing '\" + _this.file.name + \"'. \" + event.error;\n\n          _this.OnEvent(new Exports_1.AudioStreamNodeErrorEvent(_this.id, audioNodeId, event.error));\n\n          throw new Error(errorMsg);\n        };\n\n        var chunk = _this.file.slice(startOffset, endOffset);\n\n        reader.readAsArrayBuffer(chunk);\n        return stream.GetReader();\n      });\n    };\n\n    this.OnEvent = function (event) {\n      _this.events.OnEvent(event);\n\n      Exports_1.Events.Instance.OnEvent(event);\n    };\n\n    this.id = audioSourceId ? audioSourceId : Exports_1.CreateNoDashGuid();\n    this.events = new Exports_1.EventSource();\n    this.file = file;\n  }\n\n  Object.defineProperty(FileAudioSource.prototype, \"Events\", {\n    get: function () {\n      return this.events;\n    },\n    enumerable: true,\n    configurable: true\n  }); // Recommended sample rate (bytes/second).\n\n  FileAudioSource.SAMPLE_RATE = 16000 * 2; // 16 kHz * 16 bits\n  // We should stream audio at no faster than 2x real-time (i.e., send five chunks\n  // per second, with the chunk size == sample rate in bytes per second * 2 / 5).\n\n  FileAudioSource.CHUNK_SIZE = FileAudioSource.SAMPLE_RATE * 2 / 5;\n  FileAudioSource.UPLOAD_INTERVAL = 200; // milliseconds\n  // 10 seconds of audio in bytes =\n  // sample rate (bytes/second) * 600 (seconds) + 44 (size of the wave header).\n\n  FileAudioSource.MAX_SIZE = FileAudioSource.SAMPLE_RATE * 600 + 44;\n  return FileAudioSource;\n}();\n\nexports.FileAudioSource = FileAudioSource;","map":null,"metadata":{},"sourceType":"script"}