{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Exports_1 = require(\"../../common/Exports\");\n\nvar CRLF = \"\\r\\n\";\n\nvar WebsocketMessageFormatter =\n/** @class */\nfunction () {\n  function WebsocketMessageFormatter() {\n    var _this = this;\n\n    this.ToConnectionMessage = function (message) {\n      var deferral = new Exports_1.Deferred();\n\n      try {\n        if (message.MessageType === Exports_1.MessageType.Text) {\n          var textMessage = message.TextContent;\n          var headers = {};\n          var body = null;\n\n          if (textMessage) {\n            var headerBodySplit = textMessage.split(\"\\r\\n\\r\\n\");\n\n            if (headerBodySplit && headerBodySplit.length > 0) {\n              headers = _this.ParseHeaders(headerBodySplit[0]);\n\n              if (headerBodySplit.length > 1) {\n                body = headerBodySplit[1];\n              }\n            }\n          }\n\n          deferral.Resolve(new Exports_1.ConnectionMessage(message.MessageType, body, headers, message.Id));\n        } else if (message.MessageType === Exports_1.MessageType.Binary) {\n          var binaryMessage = message.BinaryContent;\n          var headers = {};\n          var body = null;\n\n          if (!binaryMessage || binaryMessage.byteLength < 2) {\n            throw new Error(\"Invalid binary message format. Header length missing.\");\n          }\n\n          var dataView = new DataView(binaryMessage);\n          var headerLength = dataView.getInt16(0);\n\n          if (binaryMessage.byteLength < headerLength + 2) {\n            throw new Error(\"Invalid binary message format. Header content missing.\");\n          }\n\n          var headersString = \"\";\n\n          for (var i = 0; i < headerLength; i++) {\n            headersString += String.fromCharCode(dataView.getInt8(i + 2));\n          }\n\n          headers = _this.ParseHeaders(headersString);\n\n          if (binaryMessage.byteLength > headerLength + 2) {\n            body = binaryMessage.slice(2 + headerLength);\n          }\n\n          deferral.Resolve(new Exports_1.ConnectionMessage(message.MessageType, body, headers, message.Id));\n        }\n      } catch (e) {\n        deferral.Reject(\"Error formatting the message. Error: \" + e);\n      }\n\n      return deferral.Promise();\n    };\n\n    this.FromConnectionMessage = function (message) {\n      var deferral = new Exports_1.Deferred();\n\n      try {\n        if (message.MessageType === Exports_1.MessageType.Text) {\n          var payload = \"\" + _this.MakeHeaders(message) + CRLF + (message.TextBody ? message.TextBody : \"\");\n          deferral.Resolve(new Exports_1.RawWebsocketMessage(Exports_1.MessageType.Text, payload, message.Id));\n        } else if (message.MessageType === Exports_1.MessageType.Binary) {\n          var headersString = _this.MakeHeaders(message);\n\n          var content = message.BinaryBody;\n          var headerInt8Array = new Int8Array(_this.StringToArrayBuffer(headersString));\n          var payload = new ArrayBuffer(2 + headerInt8Array.byteLength + (content ? content.byteLength : 0));\n          var dataView = new DataView(payload);\n          dataView.setInt16(0, headerInt8Array.length);\n\n          for (var i = 0; i < headerInt8Array.byteLength; i++) {\n            dataView.setInt8(2 + i, headerInt8Array[i]);\n          }\n\n          if (content) {\n            var bodyInt8Array = new Int8Array(content);\n\n            for (var i = 0; i < bodyInt8Array.byteLength; i++) {\n              dataView.setInt8(2 + headerInt8Array.byteLength + i, bodyInt8Array[i]);\n            }\n          }\n\n          deferral.Resolve(new Exports_1.RawWebsocketMessage(Exports_1.MessageType.Binary, payload, message.Id));\n        }\n      } catch (e) {\n        deferral.Reject(\"Error formatting the message. \" + e);\n      }\n\n      return deferral.Promise();\n    };\n\n    this.MakeHeaders = function (message) {\n      var headersString = \"\";\n\n      if (message.Headers) {\n        for (var header in message.Headers) {\n          if (header) {\n            headersString += header + \": \" + message.Headers[header] + CRLF;\n          }\n        }\n      }\n\n      return headersString;\n    };\n\n    this.ParseHeaders = function (headersString) {\n      var headers = {};\n\n      if (headersString) {\n        var headerMatches = headersString.match(/[^\\r\\n]+/g);\n\n        if (headers) {\n          for (var _i = 0, headerMatches_1 = headerMatches; _i < headerMatches_1.length; _i++) {\n            var header = headerMatches_1[_i];\n\n            if (header) {\n              var separatorIndex = header.indexOf(\":\");\n              var headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;\n              var headerValue = separatorIndex > 0 && header.length > separatorIndex + 1 ? header.substr(separatorIndex + 1).trim() : \"\";\n              headers[headerName] = headerValue;\n            }\n          }\n        }\n      }\n\n      return headers;\n    };\n\n    this.StringToArrayBuffer = function (str) {\n      var buffer = new ArrayBuffer(str.length);\n      var view = new DataView(buffer);\n\n      for (var i = 0; i < str.length; i++) {\n        view.setUint8(i, str.charCodeAt(i));\n      }\n\n      return buffer;\n    };\n  }\n\n  return WebsocketMessageFormatter;\n}();\n\nexports.WebsocketMessageFormatter = WebsocketMessageFormatter;","map":null,"metadata":{},"sourceType":"script"}