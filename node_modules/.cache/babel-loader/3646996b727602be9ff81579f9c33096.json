{"ast":null,"code":"\"use strict\";\n\nvar root_1 = require('./root');\n\nvar isArrayLike_1 = require('./isArrayLike');\n\nvar isPromise_1 = require('./isPromise');\n\nvar isObject_1 = require('./isObject');\n\nvar Observable_1 = require('../Observable');\n\nvar iterator_1 = require('../symbol/iterator');\n\nvar InnerSubscriber_1 = require('../InnerSubscriber');\n\nvar observable_1 = require('../symbol/observable');\n\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n  var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable_1.Observable) {\n    if (result._isScalar) {\n      destination.next(result.value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike_1.isArrayLike(result)) {\n    for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise_1.isPromise(result)) {\n    result.then(function (value) {\n      if (!destination.closed) {\n        destination.next(value);\n        destination.complete();\n      }\n    }, function (err) {\n      return destination.error(err);\n    }).then(null, function (err) {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root_1.root.setTimeout(function () {\n        throw err;\n      });\n    });\n    return destination;\n  } else if (result && typeof result[iterator_1.iterator] === 'function') {\n    var iterator = result[iterator_1.iterator]();\n\n    do {\n      var item = iterator.next();\n\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n\n      destination.next(item.value);\n\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[observable_1.observable] === 'function') {\n    var obs = result[observable_1.observable]();\n\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n    var msg = \"You provided \" + value + \" where a stream was expected.\" + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n\n  return null;\n}\n\nexports.subscribeToResult = subscribeToResult;","map":null,"metadata":{},"sourceType":"script"}