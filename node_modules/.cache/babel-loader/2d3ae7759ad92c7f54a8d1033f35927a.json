{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar RiffPcmEncoder =\n/** @class */\nfunction () {\n  function RiffPcmEncoder(actualSampleRate, desiredSampleRate) {\n    var _this = this;\n\n    this.channelCount = 1;\n\n    this.Encode = function (needHeader, actualAudioFrame) {\n      var audioFrame = _this.DownSampleAudioFrame(actualAudioFrame, _this.actualSampleRate, _this.desiredSampleRate);\n\n      if (!audioFrame) {\n        return null;\n      }\n\n      var audioLength = audioFrame.length * 2;\n\n      if (!needHeader) {\n        var buffer_1 = new ArrayBuffer(audioLength);\n        var view_1 = new DataView(buffer_1);\n\n        _this.FloatTo16BitPCM(view_1, 0, audioFrame);\n\n        return buffer_1;\n      }\n\n      var buffer = new ArrayBuffer(44 + audioLength);\n      var bitsPerSample = 16;\n      var bytesPerSample = bitsPerSample / 8; // We dont know ahead of time about the length of audio to stream. So set to 0.\n\n      var fileLength = 0; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\n\n      var view = new DataView(buffer);\n      /* RIFF identifier */\n\n      _this.SetString(view, 0, \"RIFF\");\n      /* file length */\n\n\n      view.setUint32(4, fileLength, true);\n      /* RIFF type & Format */\n\n      _this.SetString(view, 8, \"WAVEfmt \");\n      /* format chunk length */\n\n\n      view.setUint32(16, 16, true);\n      /* sample format (raw) */\n\n      view.setUint16(20, 1, true);\n      /* channel count */\n\n      view.setUint16(22, _this.channelCount, true);\n      /* sample rate */\n\n      view.setUint32(24, _this.desiredSampleRate, true);\n      /* byte rate (sample rate * block align) */\n\n      view.setUint32(28, _this.desiredSampleRate * _this.channelCount * bytesPerSample, true);\n      /* block align (channel count * bytes per sample) */\n\n      view.setUint16(32, _this.channelCount * bytesPerSample, true);\n      /* bits per sample */\n\n      view.setUint16(34, bitsPerSample, true);\n      /* data chunk identifier */\n\n      _this.SetString(view, 36, \"data\");\n      /* data chunk length */\n\n\n      view.setUint32(40, fileLength, true);\n\n      _this.FloatTo16BitPCM(view, 44, audioFrame);\n\n      return buffer;\n    };\n\n    this.SetString = function (view, offset, str) {\n      for (var i = 0; i < str.length; i++) {\n        view.setUint8(offset + i, str.charCodeAt(i));\n      }\n    };\n\n    this.FloatTo16BitPCM = function (view, offset, input) {\n      for (var i = 0; i < input.length; i++, offset += 2) {\n        var s = Math.max(-1, Math.min(1, input[i]));\n        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n      }\n    };\n\n    this.DownSampleAudioFrame = function (srcFrame, srcRate, dstRate) {\n      if (dstRate === srcRate || dstRate > srcRate) {\n        return srcFrame;\n      }\n\n      var ratio = srcRate / dstRate;\n      var dstLength = Math.round(srcFrame.length / ratio);\n      var dstFrame = new Float32Array(dstLength);\n      var srcOffset = 0;\n      var dstOffset = 0;\n\n      while (dstOffset < dstLength) {\n        var nextSrcOffset = Math.round((dstOffset + 1) * ratio);\n        var accum = 0;\n        var count = 0;\n\n        while (srcOffset < nextSrcOffset && srcOffset < srcFrame.length) {\n          accum += srcFrame[srcOffset++];\n          count++;\n        }\n\n        dstFrame[dstOffset++] = accum / count;\n      }\n\n      return dstFrame;\n    };\n\n    this.actualSampleRate = actualSampleRate;\n    this.desiredSampleRate = desiredSampleRate;\n  }\n\n  return RiffPcmEncoder;\n}();\n\nexports.RiffPcmEncoder = RiffPcmEncoder;","map":null,"metadata":{},"sourceType":"script"}