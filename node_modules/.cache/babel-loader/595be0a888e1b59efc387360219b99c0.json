{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _memoizeOne = _interopRequireDefault(require(\"memoize-one\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _best = _interopRequireDefault(require(\"./best\"));\n\nvar _Context = _interopRequireDefault(require(\"./Context\"));\n\nvar _ScrollSpy = _interopRequireDefault(require(\"./ScrollSpy\"));\n\nvar _ScrollTo = _interopRequireDefault(require(\"./ScrollTo\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction getView() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      scrollable = _ref.current;\n\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      itemContainer = _ref2.current;\n\n  var scrollingTo = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (itemContainer && scrollable) {\n    var scrollLeft = scrollingTo || scrollable.scrollLeft;\n    var items = itemContainer.children; // This will enumerate <li> inside <FilmStrip>\n\n    var scrollCenter = scrollLeft + scrollable.offsetWidth / 2;\n    var index = (0, _best.default)([].slice.call(items), function (item) {\n      var offsetCenter = item.offsetLeft + item.offsetWidth / 2;\n      return 1 / Math.abs(scrollCenter - offsetCenter);\n    });\n\n    if (~index) {\n      var item = items[index];\n      var offsetCenter = item.offsetLeft + item.offsetWidth / 2;\n      var indexFraction = index + (scrollCenter - offsetCenter) / item.offsetWidth; // We \"fix\" indexFraction if the viewport is at the start/end of the content\n      // This is to simplify code that use Math.round(indexFraction) to find the scrollable index\n      // if (scrollLeft === 0) {\n      //   indexFraction = 0;\n      // } else if (scrollLeft >= scrollable.scrollWidth - scrollable.offsetWidth) {\n      //   indexFraction = items.length - 1;\n      // } else if (indexFraction % 1 > .99 || indexFraction % 1 < .01) {\n      //   indexFraction = Math.round(indexFraction);\n      // }\n\n      if (indexFraction % 1 > .99 || indexFraction % 1 < .01) {\n        indexFraction = Math.round(indexFraction);\n      }\n\n      var selectedIndex;\n\n      if (scrollLeft === 0) {\n        selectedIndex = 0;\n      } else if (scrollLeft >= scrollable.scrollWidth - scrollable.offsetWidth) {\n        selectedIndex = items.length - 1;\n      } else {\n        selectedIndex = Math.round(indexFraction);\n      }\n\n      return {\n        index: selectedIndex,\n        indexFraction: indexFraction\n      };\n    }\n  }\n}\n\nfunction getScrollLeft() {\n  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      scrollable = _ref3.current;\n\n  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      itemContainer = _ref4.current;\n\n  var index = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (itemContainer && scrollable) {\n    var items = itemContainer.children; // This will enumerate <li> inside <FilmStrip>\n\n    var item = items[Math.max(0, Math.min(items.length - 1, index))];\n\n    if (item) {\n      var itemOffsetCenter = item.offsetLeft + item.offsetWidth / 2;\n      return itemOffsetCenter - scrollable.offsetWidth / 2;\n    }\n  }\n}\n\nvar FilmComposer =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(FilmComposer, _React$Component);\n\n  function FilmComposer(props) {\n    var _this;\n\n    _classCallCheck(this, FilmComposer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FilmComposer).call(this, props));\n    _this.handleScroll = _this.handleScroll.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleScrollToEnd = _this.handleScrollToEnd.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.itemContainerRef = _react.default.createRef();\n    _this.scrollableRef = _react.default.createRef();\n    _this.mergeContext = (0, _memoizeOne.default)(function (state) {\n      var numItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return _objectSpread({}, state, {\n        numItems: numItems\n      });\n    });\n    _this.state = {\n      context: {\n        itemContainerRef: _this.itemContainerRef,\n        scrollableRef: _this.scrollableRef,\n        scrollBarPercentage: '0%',\n        scrollBarWidth: '0%',\n        scrolling: false,\n        scrollTo: function scrollTo(_scrollTo) {\n          _this.setState(function (state) {\n            var view = getView(_this.scrollableRef, _this.itemContainerRef, state.scrollLeft);\n\n            if (view) {\n              var index = view.index,\n                  indexFraction = view.indexFraction;\n\n              var targetIndex = _scrollTo({\n                index: index,\n                indexFraction: indexFraction\n              });\n\n              if (typeof targetIndex === 'number') {\n                return {\n                  scrollLeft: getScrollLeft(_this.scrollableRef, _this.itemContainerRef, targetIndex)\n                };\n              }\n            }\n          });\n        },\n        scrollOneLeft: function scrollOneLeft() {\n          _this.state.context.scrollTo(function (_ref5) {\n            var indexFraction = _ref5.indexFraction;\n            return Math.ceil(indexFraction) - 1;\n          });\n        },\n        scrollOneRight: function scrollOneRight() {\n          _this.state.context.scrollTo(function (_ref6) {\n            var indexFraction = _ref6.indexFraction;\n            return Math.floor(indexFraction) + 1;\n          });\n        }\n      },\n      scrollLeft: null\n    };\n    return _this;\n  }\n\n  _createClass(FilmComposer, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      clearTimeout(this.scrollTimeout);\n    }\n  }, {\n    key: \"handleScroll\",\n    value: function handleScroll(_ref7) {\n      var _this2 = this;\n\n      var scrollBarPercentage = _ref7.fraction,\n          initial = _ref7.initial,\n          scrollBarWidth = _ref7.width;\n      this.setState(function (_ref8) {\n        var context = _ref8.context,\n            scrollLeft = _ref8.scrollLeft;\n        var view = getView(_this2.scrollableRef, _this2.itemContainerRef, scrollLeft);\n\n        if (view) {\n          var index = view.index,\n              indexFraction = view.indexFraction;\n          return {\n            context: _objectSpread({}, context, {\n              index: index,\n              indexFraction: indexFraction,\n              scrolling: !initial,\n              scrollBarPercentage: scrollBarPercentage,\n              scrollBarWidth: scrollBarWidth\n            })\n          };\n        }\n      });\n\n      if (!initial) {\n        clearTimeout(this.scrollTimeout);\n        this.scrollTimeout = setTimeout(function () {\n          _this2.setState(function (_ref9) {\n            var context = _ref9.context;\n            return {\n              context: _objectSpread({}, context, {\n                scrolling: false\n              })\n            };\n          });\n        }, 500);\n      }\n    }\n  }, {\n    key: \"handleScrollToEnd\",\n    value: function handleScrollToEnd() {\n      this.setState(function () {\n        return {\n          scrollLeft: null\n        };\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          numItems = _this$props.numItems,\n          scrollableRef = this.scrollableRef,\n          _this$state = this.state,\n          context = _this$state.context,\n          scrollLeft = _this$state.scrollLeft;\n      return _react.default.createElement(_Context.default.Provider, {\n        value: this.mergeContext(context, numItems)\n      }, children, _react.default.createElement(_ScrollSpy.default, {\n        onScroll: this.handleScroll,\n        targetRef: scrollableRef\n      }), typeof scrollLeft === 'number' && _react.default.createElement(_ScrollTo.default, {\n        onEnd: this.handleScrollToEnd,\n        scrollLeft: scrollLeft,\n        targetRef: scrollableRef\n      }));\n    }\n  }]);\n\n  return FilmComposer;\n}(_react.default.Component);\n\nexports.default = FilmComposer;","map":null,"metadata":{},"sourceType":"script"}