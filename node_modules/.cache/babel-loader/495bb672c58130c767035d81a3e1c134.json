{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _memoizeOne = require('memoize-one');\n\nvar _memoizeOne2 = _interopRequireDefault(_memoizeOne);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Context = require('./Context');\n\nvar _Context2 = _interopRequireDefault(_Context);\n\nvar _prefix = require('./prefix');\n\nvar _prefix2 = _interopRequireDefault(_prefix);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction chainListener() {\n  for (var _len = arguments.length, listeners = Array(_len), _key = 0; _key < _len; _key++) {\n    listeners[_key] = arguments[_key];\n  }\n\n  return function () {\n    var _this = this,\n        _arguments = arguments;\n\n    listeners.forEach(function (listener) {\n      return listener.apply(_this, _arguments);\n    });\n  };\n}\n\nvar Composer = function (_React$Component) {\n  _inherits(Composer, _React$Component);\n\n  function Composer(props) {\n    _classCallCheck(this, Composer);\n\n    var _this2 = _possibleConstructorReturn(this, (Composer.__proto__ || Object.getPrototypeOf(Composer)).call(this, props));\n\n    _this2.createGrammarList = (0, _memoizeOne2.default)(function (speechGrammarList, grammar) {\n      var grammarList = new speechGrammarList();\n      grammar && grammarList.addFromString(grammar, 1);\n      return grammarList;\n    });\n    _this2.createRecognition = (0, _memoizeOne2.default)(function (speechRecognition) {\n      return speechRecognition && new speechRecognition();\n    });\n    _this2.handleAudioEnd = _this2.handleAudioEnd.bind(_this2);\n    _this2.handleAudioStart = _this2.handleAudioStart.bind(_this2);\n    _this2.handleEnd = _this2.handleEnd.bind(_this2);\n    _this2.handleError = _this2.handleError.bind(_this2);\n    _this2.handleRawEvent = _this2.handleRawEvent.bind(_this2);\n    _this2.handleResult = _this2.handleResult.bind(_this2);\n    _this2.handleStart = _this2.handleStart.bind(_this2);\n    _this2.state = {\n      readyState: 0,\n      supported: !!props.speechRecognition\n    };\n    return _this2;\n  }\n\n  _createClass(Composer, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var recognition = this.recognition;\n      var nextState = void 0;\n\n      if (nextProps.speechRecognition !== this.props.speechRecognition) {\n        recognition && recognition.abort();\n        recognition = this.recognition = null;\n        nextState = _extends({}, nextState, {\n          supported: !!nextProps.speechRecognition\n        });\n      }\n\n      if (nextProps.started !== this.props.started) {\n        if (nextProps.started) {\n          this.start(nextProps);\n        } else {\n          recognition && recognition.abort();\n        }\n      }\n\n      nextState && this.setState(function () {\n        return nextState;\n      });\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.recognition && this.recognition.abort();\n    }\n  }, {\n    key: 'handleAudioEnd',\n    value: function handleAudioEnd() {\n      this.setState(function () {\n        return {\n          readyState: 3\n        };\n      });\n    }\n  }, {\n    key: 'handleAudioStart',\n    value: function handleAudioStart() {\n      this.setState(function () {\n        return {\n          readyState: 2\n        };\n      }); // Web Speech API does not emit \"result\" when nothing is heard, and Chrome does not emit \"nomatch\" event.\n      // Because we emitted onProgress, we should emit \"dictate\" if not error, so they works in pair.\n\n      this.emitDictateOnEnd = true;\n      this.props.onProgress && this.props.onProgress({});\n    }\n  }, {\n    key: 'handleEnd',\n    value: function handleEnd() {\n      if (this.emitDictateOnEnd) {\n        this.props.onDictate && this.props.onDictate({});\n      }\n\n      this.setState(function () {\n        return {\n          readyState: 0\n        };\n      });\n    }\n  }, {\n    key: 'handleError',\n    value: function handleError(event) {\n      this.setState(function () {\n        return _extends({\n          readyState: 0\n        }, event.error === 'not-allowed' && {\n          supported: false\n        });\n      }); // Error out, no need to emit \"dictate\"\n\n      this.emitDictateOnEnd = false;\n      this.props.onError && this.props.onError(event);\n    }\n  }, {\n    key: 'handleRawEvent',\n    value: function handleRawEvent(event) {\n      this.props.onRawEvent && this.props.onRawEvent(event);\n    }\n  }, {\n    key: 'handleResult',\n    value: function handleResult(event) {\n      var props = this.props;\n      var rawResults = event.results;\n\n      if (rawResults.length) {\n        var results = [].map.call(rawResults, function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 1),\n              firstAlt = _ref2[0];\n\n          return {\n            confidence: firstAlt.confidence,\n            transcript: firstAlt.transcript\n          };\n        });\n\n        var _rawResults = _slicedToArray(rawResults, 1),\n            first = _rawResults[0];\n\n        if (first.isFinal) {\n          this.emitDictateOnEnd = false;\n          props.onDictate && props.onDictate({\n            result: results[0]\n          });\n        } else {\n          props.onProgress && props.onProgress({\n            results: results\n          });\n        }\n      }\n    }\n  }, {\n    key: 'handleStart',\n    value: function handleStart() {\n      this.setState(function () {\n        return {\n          readyState: 1\n        };\n      });\n    }\n  }, {\n    key: 'start',\n    value: function start(props) {\n      this.recognition && this.recognition.abort();\n\n      if (!this.state.supported) {\n        throw new Error('Speech recognition is not supported');\n      }\n\n      var recognition = this.recognition = this.createRecognition(props.speechRecognition);\n      recognition.grammars = this.createGrammarList(props.speechGrammarList, props.grammar);\n      recognition.lang = props.lang;\n      recognition.interimResults = true;\n      recognition.onaudioend = chainListener(this.handleAudioEnd, this.handleRawEvent);\n      recognition.onaudiostart = chainListener(this.handleAudioStart, this.handleRawEvent);\n      recognition.onend = chainListener(this.handleEnd, this.handleRawEvent);\n      recognition.onerror = chainListener(this.handleError, this.handleRawEvent);\n      recognition.onnomatch = this.handleRawEvent;\n      recognition.onresult = chainListener(this.handleResult, this.handleRawEvent);\n      recognition.onsoundend = this.handleRawEvent;\n      recognition.onsoundstart = this.handleRawEvent;\n      recognition.onspeechend = this.handleRawEvent;\n      recognition.onspeechstart = this.handleRawEvent;\n      recognition.onstart = chainListener(this.handleStart, this.handleRawEvent);\n      props.extra && Object.keys(props.extra).forEach(function (key) {\n        recognition[key] = props.extra[key];\n      });\n      recognition.start();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var props = this.props,\n          state = this.state;\n      var children = props.children;\n      return _react2.default.createElement(_Context2.default.Provider, {\n        value: state\n      }, _react2.default.createElement(_Context2.default.Consumer, null, function (context) {\n        return typeof children === 'function' ? children(context) : children;\n      }));\n    }\n  }]);\n\n  return Composer;\n}(_react2.default.Component);\n\nexports.default = Composer;\nComposer.defaultProps = {\n  speechGrammarList: (0, _prefix2.default)('SpeechGrammarList'),\n  speechRecognition: (0, _prefix2.default)('SpeechRecognition')\n};\nComposer.propTypes = {\n  extra: _propTypes2.default.any,\n  lang: _propTypes2.default.string,\n  onDictate: _propTypes2.default.func,\n  onError: _propTypes2.default.func,\n  onProgress: _propTypes2.default.func,\n  onRawEvent: _propTypes2.default.func,\n  speechGrammarList: _propTypes2.default.any,\n  speechRecognition: _propTypes2.default.any\n};","map":null,"metadata":{},"sourceType":"script"}