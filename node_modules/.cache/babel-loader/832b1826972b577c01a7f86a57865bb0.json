{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = createContext;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _QueuedUtterance = _interopRequireDefault(require(\"./QueuedUtterance\"));\n\nfunction createContext(_ref) {\n  var speechSynthesis = _ref.speechSynthesis,\n      SpeechSynthesisUtterance = _ref.SpeechSynthesisUtterance;\n  var ponyfill = {\n    speechSynthesis: speechSynthesis,\n    SpeechSynthesisUtterance: SpeechSynthesisUtterance\n  };\n  var queueWithCurrent = [];\n  var running;\n\n  var run =\n  /*#__PURE__*/\n  function () {\n    var _ref2 = (0, _asyncToGenerator2[\"default\"])(\n    /*#__PURE__*/\n    _regenerator[\"default\"].mark(function _callee2() {\n      return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!running) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 2:\n              running = true;\n              _context2.prev = 3;\n              return _context2.delegateYield(\n              /*#__PURE__*/\n              _regenerator[\"default\"].mark(function _callee() {\n                var utterance;\n                return _regenerator[\"default\"].wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        if (!(utterance = queueWithCurrent[0])) {\n                          _context.next = 12;\n                          break;\n                        }\n\n                        _context.prev = 1;\n                        _context.next = 4;\n                        return utterance.speak(ponyfill);\n\n                      case 4:\n                        _context.next = 9;\n                        break;\n\n                      case 6:\n                        _context.prev = 6;\n                        _context.t0 = _context[\"catch\"](1); // TODO: If the error is due to Safari restriction on user touch\n                        //       The next loop on the next audio will also fail because it was not queued with a user touch\n\n                        _context.t0.message !== 'cancelled' && console.error(_context.t0);\n\n                      case 9:\n                        queueWithCurrent = queueWithCurrent.filter(function (target) {\n                          return target !== utterance;\n                        });\n                        _context.next = 0;\n                        break;\n\n                      case 12:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[1, 6]]);\n              })(), \"t0\", 5);\n\n            case 5:\n              _context2.prev = 5;\n              running = false;\n              return _context2.finish(5);\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[3,, 5, 8]]);\n    }));\n\n    return function run() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  return {\n    cancel: function () {\n      var _cancel = (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee3(id) {\n        var index;\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                index = queueWithCurrent.findIndex(function (utterance) {\n                  return utterance.id === id;\n                }); // We would leave the cancelled utterance in the queue because we want to reject the promise.\n\n                _context3.next = 3;\n                return queueWithCurrent[index].cancel();\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function cancel(_x) {\n        return _cancel.apply(this, arguments);\n      }\n\n      return cancel;\n    }(),\n    setPonyfill: function setPonyfill(_ref3) {\n      var speechSynthesis = _ref3.speechSynthesis,\n          SpeechSynthesisUtterance = _ref3.SpeechSynthesisUtterance;\n      ponyfill = {\n        speechSynthesis: speechSynthesis,\n        SpeechSynthesisUtterance: SpeechSynthesisUtterance\n      };\n    },\n    speak: function speak(utteranceLike) {\n      // console.debug(`QUEUED: ${ utteranceLike.text }`);\n      if (utteranceLike.id && queueWithCurrent.find(function (_ref4) {\n        var id = _ref4.id;\n        return id === utteranceLike.id;\n      })) {\n        // Do not queue duplicated speak with same unique ID\n        // console.debug('NOT QUEUEING DUPE');\n        return Promise.reject(new Error('Utterance with same ID is queued'));\n      }\n\n      var utterance = new _QueuedUtterance[\"default\"](utteranceLike);\n      queueWithCurrent = [].concat((0, _toConsumableArray2[\"default\"])(queueWithCurrent), [utterance]);\n      run();\n      return utterance.promise;\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"script"}