{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Error_1 = require(\"./Error\");\n\nvar Guid_1 = require(\"./Guid\");\n\nvar Queue_1 = require(\"./Queue\");\n\nvar Stream =\n/** @class */\nfunction () {\n  function Stream(streamId) {\n    var _this = this;\n\n    this.readerIdCounter = 1;\n    this.isEnded = false;\n\n    this.Write = function (buffer) {\n      _this.ThrowIfClosed();\n\n      _this.WriteStreamChunk({\n        Buffer: buffer,\n        IsEnd: false\n      });\n    };\n\n    this.GetReader = function () {\n      var readerId = _this.readerIdCounter;\n      _this.readerIdCounter++;\n      var readerQueue = new Queue_1.Queue();\n      var currentLength = _this.streambuffer.length;\n      _this.readerQueues[readerId] = readerQueue;\n\n      for (var i = 0; i < currentLength; i++) {\n        readerQueue.Enqueue(_this.streambuffer[i]);\n      }\n\n      return new StreamReader(_this.id, readerQueue, function () {\n        delete _this.readerQueues[readerId];\n      });\n    };\n\n    this.Close = function () {\n      if (!_this.isEnded) {\n        _this.WriteStreamChunk({\n          Buffer: null,\n          IsEnd: true\n        });\n\n        _this.isEnded = true;\n      }\n    };\n\n    this.WriteStreamChunk = function (streamChunk) {\n      _this.ThrowIfClosed();\n\n      _this.streambuffer.push(streamChunk);\n\n      for (var readerId in _this.readerQueues) {\n        if (!_this.readerQueues[readerId].IsDisposed()) {\n          try {\n            _this.readerQueues[readerId].Enqueue(streamChunk);\n          } catch (e) {// Do nothing\n          }\n        }\n      }\n    };\n\n    this.ThrowIfClosed = function () {\n      if (_this.isEnded) {\n        throw new Error_1.InvalidOperationError(\"Stream closed\");\n      }\n    };\n\n    this.id = streamId ? streamId : Guid_1.CreateNoDashGuid();\n    this.streambuffer = [];\n    this.readerQueues = {};\n  }\n\n  Object.defineProperty(Stream.prototype, \"IsClosed\", {\n    get: function () {\n      return this.isEnded;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Stream.prototype, \"Id\", {\n    get: function () {\n      return this.id;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Stream;\n}();\n\nexports.Stream = Stream; // tslint:disable-next-line:max-classes-per-file\n\nvar StreamReader =\n/** @class */\nfunction () {\n  function StreamReader(streamId, readerQueue, onClose) {\n    var _this = this;\n\n    this.isClosed = false;\n\n    this.Read = function () {\n      if (_this.IsClosed) {\n        throw new Error_1.InvalidOperationError(\"StreamReader closed\");\n      }\n\n      return _this.readerQueue.Dequeue().OnSuccessContinueWith(function (streamChunk) {\n        if (streamChunk.IsEnd) {\n          _this.readerQueue.Dispose(\"End of stream reached\");\n        }\n\n        return streamChunk;\n      });\n    };\n\n    this.Close = function () {\n      if (!_this.isClosed) {\n        _this.isClosed = true;\n\n        _this.readerQueue.Dispose(\"StreamReader closed\");\n\n        _this.onClose();\n      }\n    };\n\n    this.readerQueue = readerQueue;\n    this.onClose = onClose;\n    this.streamId = streamId;\n  }\n\n  Object.defineProperty(StreamReader.prototype, \"IsClosed\", {\n    get: function () {\n      return this.isClosed;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StreamReader.prototype, \"StreamId\", {\n    get: function () {\n      return this.streamId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return StreamReader;\n}();\n\nexports.StreamReader = StreamReader;","map":null,"metadata":{},"sourceType":"script"}