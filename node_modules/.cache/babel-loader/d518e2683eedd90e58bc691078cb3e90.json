{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Exports_1 = require(\"../common/Exports\");\n\nvar MicAudioSource =\n/** @class */\nfunction () {\n  function MicAudioSource(recorder, audioSourceId) {\n    var _this = this;\n\n    this.streams = {};\n\n    this.TurnOn = function () {\n      if (_this.initializeDeferral) {\n        return _this.initializeDeferral.Promise();\n      }\n\n      _this.initializeDeferral = new Exports_1.Deferred();\n\n      _this.CreateAudioContext();\n\n      var nav = window.navigator;\n      var getUserMedia = nav.getUserMedia || nav.webkitGetUserMedia || nav.mozGetUserMedia || nav.msGetUserMedia;\n\n      if (!!nav.mediaDevices) {\n        getUserMedia = function (constraints, successCallback, errorCallback) {\n          nav.mediaDevices.getUserMedia(constraints).then(successCallback).catch(errorCallback);\n        };\n      }\n\n      if (!getUserMedia) {\n        var errorMsg = \"Browser does not support getUserMedia.\";\n\n        _this.initializeDeferral.Reject(errorMsg);\n\n        _this.OnEvent(new Exports_1.AudioSourceErrorEvent(errorMsg, \"\")); // mic initialized error - no streamid at this point\n\n      } else {\n        var next = function () {\n          _this.OnEvent(new Exports_1.AudioSourceInitializingEvent(_this.id)); // no stream id\n\n\n          getUserMedia({\n            audio: true,\n            video: false\n          }, function (mediaStream) {\n            _this.mediaStream = mediaStream;\n\n            _this.OnEvent(new Exports_1.AudioSourceReadyEvent(_this.id));\n\n            _this.initializeDeferral.Resolve(true);\n          }, function (error) {\n            var errorMsg = \"Error occurred during microphone initialization: \" + error;\n            var tmp = _this.initializeDeferral; // HACK: this should be handled through onError callbacks of all promises up the stack.\n            // Unfortunately, the current implementation does not provide an easy way to reject promises\n            // without a lot of code replication.\n            // TODO: fix promise implementation, allow for a graceful reject chaining.\n\n            _this.initializeDeferral = null;\n            tmp.Reject(errorMsg); // this will bubble up through the whole chain of promises,\n            // with each new level adding extra \"Unhandled callback error\" prefix to the error message.\n            // The following line is not guaranteed to be executed.\n\n            _this.OnEvent(new Exports_1.AudioSourceErrorEvent(_this.id, errorMsg));\n          });\n        };\n\n        if (_this.context.state === \"suspended\") {\n          // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.\n          // https://github.com/WebAudio/web-audio-api/issues/790\n          _this.context.resume().then(next, function (reason) {\n            _this.initializeDeferral.Reject(\"Failed to initialize audio context: \" + reason);\n          });\n        } else {\n          next();\n        }\n      }\n\n      return _this.initializeDeferral.Promise();\n    };\n\n    this.Id = function () {\n      return _this.id;\n    };\n\n    this.Attach = function (audioNodeId) {\n      _this.OnEvent(new Exports_1.AudioStreamNodeAttachingEvent(_this.id, audioNodeId));\n\n      return _this.Listen(audioNodeId).OnSuccessContinueWith(function (streamReader) {\n        _this.OnEvent(new Exports_1.AudioStreamNodeAttachedEvent(_this.id, audioNodeId));\n\n        return {\n          Detach: function () {\n            streamReader.Close();\n            delete _this.streams[audioNodeId];\n\n            _this.OnEvent(new Exports_1.AudioStreamNodeDetachedEvent(_this.id, audioNodeId));\n\n            _this.TurnOff();\n          },\n          Id: function () {\n            return audioNodeId;\n          },\n          Read: function () {\n            return streamReader.Read();\n          }\n        };\n      });\n    };\n\n    this.Detach = function (audioNodeId) {\n      if (audioNodeId && _this.streams[audioNodeId]) {\n        _this.streams[audioNodeId].Close();\n\n        delete _this.streams[audioNodeId];\n\n        _this.OnEvent(new Exports_1.AudioStreamNodeDetachedEvent(_this.id, audioNodeId));\n      }\n    };\n\n    this.TurnOff = function () {\n      for (var streamId in _this.streams) {\n        if (streamId) {\n          var stream = _this.streams[streamId];\n\n          if (stream) {\n            stream.Close();\n          }\n        }\n      }\n\n      _this.OnEvent(new Exports_1.AudioSourceOffEvent(_this.id)); // no stream now\n\n\n      _this.initializeDeferral = null;\n\n      _this.DestroyAudioContext();\n\n      return Exports_1.PromiseHelper.FromResult(true);\n    };\n\n    this.Listen = function (audioNodeId) {\n      return _this.TurnOn().OnSuccessContinueWith(function (_) {\n        var stream = new Exports_1.Stream(audioNodeId);\n        _this.streams[audioNodeId] = stream;\n\n        try {\n          _this.recorder.Record(_this.context, _this.mediaStream, stream);\n        } catch (error) {\n          _this.OnEvent(new Exports_1.AudioStreamNodeErrorEvent(_this.id, audioNodeId, error));\n\n          throw error;\n        }\n\n        return stream.GetReader();\n      });\n    };\n\n    this.OnEvent = function (event) {\n      _this.events.OnEvent(event);\n\n      Exports_1.Events.Instance.OnEvent(event);\n    };\n\n    this.CreateAudioContext = function () {\n      if (!!_this.context) {\n        return;\n      } // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\n\n\n      var AudioContext = window.AudioContext || window.webkitAudioContext || false;\n\n      if (!AudioContext) {\n        throw new Error(\"Browser does not support Web Audio API (AudioContext is not available).\");\n      }\n\n      _this.context = new AudioContext();\n    };\n\n    this.DestroyAudioContext = function () {\n      if (!_this.context) {\n        return;\n      }\n\n      _this.recorder.ReleaseMediaResources(_this.context);\n\n      if (\"close\" in _this.context) {\n        _this.context.close();\n\n        _this.context = null;\n      } else if (_this.context.state === \"running\") {\n        // Suspend actually takes a callback, but analogous to the\n        // resume method, it'll be only fired if suspend is called\n        // in a direct response to a user action. The later is not always\n        // the case, as TurnOff is also called, when we receive an\n        // end-of-speech message from the service. So, doing a best effort\n        // fire-and-forget here.\n        _this.context.suspend();\n      }\n    };\n\n    this.id = audioSourceId ? audioSourceId : Exports_1.CreateNoDashGuid();\n    this.events = new Exports_1.EventSource();\n    this.recorder = recorder;\n  }\n\n  Object.defineProperty(MicAudioSource.prototype, \"Events\", {\n    get: function () {\n      return this.events;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return MicAudioSource;\n}();\n\nexports.MicAudioSource = MicAudioSource;","map":null,"metadata":{},"sourceType":"script"}