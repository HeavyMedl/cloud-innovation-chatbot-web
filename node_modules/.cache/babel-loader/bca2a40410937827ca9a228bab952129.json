{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _createDeferred = _interopRequireDefault(require(\"./createDeferred\"));\n\nfunction createNativeUtterance(utteranceLike, ponyfill) {\n  var speechSynthesis = ponyfill.speechSynthesis,\n      SpeechSynthesisUtterance = ponyfill.SpeechSynthesisUtterance;\n  var lang = utteranceLike.lang,\n      onBoundary = utteranceLike.onBoundary,\n      pitch = utteranceLike.pitch,\n      rate = utteranceLike.rate,\n      text = utteranceLike.text,\n      voice = utteranceLike.voice,\n      volume = utteranceLike.volume;\n  var utterance = new SpeechSynthesisUtterance(text);\n  var targetVoice;\n\n  if (typeof voice === 'function') {\n    targetVoice = voice.call(speechSynthesis, speechSynthesis.getVoices());\n  } else {\n    var _ref = voice || {},\n        voiceURI = _ref.voiceURI;\n\n    targetVoice = voiceURI && [].find.call([].slice.call(speechSynthesis.getVoices()), function (v) {\n      return v.voiceURI === voiceURI;\n    });\n  } // Edge will mute if \"lang\" is set to \"\"\n\n\n  utterance.lang = lang || '';\n\n  if (pitch || pitch === 0) {\n    utterance.pitch = pitch;\n  }\n\n  if (rate || rate === 0) {\n    utterance.rate = rate;\n  } // Cognitive Services will error when \"voice\" is set to \"null\"\n  // Edge will error when \"voice\" is set to \"undefined\"\n\n\n  if (targetVoice) {\n    utterance.voice = targetVoice;\n  }\n\n  if (volume || volume === 0) {\n    utterance.volume = volume;\n  }\n\n  if (utterance.addEventListener && onBoundary) {\n    utterance.addEventListener('boundary', onBoundary); // Since browser quirks, start/error/end events are emulated for best compatibility\n  }\n\n  return utterance;\n}\n\nfunction speakUtterance(_x, _x2, _x3) {\n  return _speakUtterance.apply(this, arguments);\n}\n\nfunction _speakUtterance() {\n  _speakUtterance = (0, _asyncToGenerator2[\"default\"])(\n  /*#__PURE__*/\n  _regenerator[\"default\"].mark(function _callee4(ponyfill, utteranceLike, startCallback) {\n    var speechSynthesis, utterance, startDeferred, errorDeferred, endDeferred, startEvent, finishedSpeaking, endPromise, endEvent;\n    return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            speechSynthesis = ponyfill.speechSynthesis;\n            utterance = createNativeUtterance(utteranceLike, ponyfill);\n            startDeferred = (0, _createDeferred[\"default\"])();\n            errorDeferred = (0, _createDeferred[\"default\"])();\n            endDeferred = (0, _createDeferred[\"default\"])();\n            utterance.addEventListener('end', endDeferred.resolve);\n            utterance.addEventListener('error', errorDeferred.resolve);\n            utterance.addEventListener('start', startDeferred.resolve); // if (speechSynthesis.speaking) {\n            //   console.warn(`ASSERTION: speechSynthesis.speaking should not be truthy before we call speak`);\n            // }\n\n            speechSynthesis.speak(utterance); // await startDeferred.promise;\n\n            _context4.next = 11;\n            return Promise.race([errorDeferred.promise, startDeferred.promise]);\n\n          case 11:\n            startEvent = _context4.sent;\n\n            if (!(startEvent.type === 'error')) {\n              _context4.next = 14;\n              break;\n            }\n\n            throw startEvent.error;\n\n          case 14:\n            endPromise = Promise.race([errorDeferred.promise, endDeferred.promise]);\n            startCallback && startCallback(\n            /*#__PURE__*/\n            (0, _asyncToGenerator2[\"default\"])(\n            /*#__PURE__*/\n            _regenerator[\"default\"].mark(function _callee3() {\n              return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      if (finishedSpeaking) {\n                        _context3.next = 4;\n                        break;\n                      }\n\n                      speechSynthesis.cancel();\n                      _context3.next = 4;\n                      return endPromise;\n\n                    case 4:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3);\n            })));\n            _context4.next = 18;\n            return endPromise;\n\n          case 18:\n            endEvent = _context4.sent;\n            finishedSpeaking = true; // if (speechSynthesis.speaking) {\n            //   console.warn(`ASSERTION: speechSynthesis.speaking should not be truthy after speak is stopped`);\n            // }\n            // console.debug(`ENDED: ${ utterance.text }`);\n\n            if (!(endEvent.type === 'error')) {\n              _context4.next = 22;\n              break;\n            }\n\n            throw endEvent.error;\n\n          case 22:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _speakUtterance.apply(this, arguments);\n}\n\nvar QueuedUtterance =\n/*#__PURE__*/\nfunction () {\n  function QueuedUtterance(utteranceLike) {\n    (0, _classCallCheck2[\"default\"])(this, QueuedUtterance);\n    this._cancelled = false;\n    this._deferred = (0, _createDeferred[\"default\"])();\n    this._ponyfill = null;\n    this._speaking = false;\n    this._utteranceLike = utteranceLike;\n    this.id = utteranceLike.id;\n    this.promise = this._deferred.promise;\n  }\n\n  (0, _createClass2[\"default\"])(QueuedUtterance, [{\n    key: \"cancel\",\n    value: function () {\n      var _cancel = (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee() {\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this._cancelled = true;\n                _context.t0 = this._cancel;\n\n                if (!_context.t0) {\n                  _context.next = 5;\n                  break;\n                }\n\n                _context.next = 5;\n                return this._cancel();\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function cancel() {\n        return _cancel.apply(this, arguments);\n      }\n\n      return cancel;\n    }()\n  }, {\n    key: \"speak\",\n    value: function speak(ponyfill) {\n      var _this = this;\n\n      (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee2() {\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!_this._cancelled) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error('cancelled');\n\n              case 2:\n                _context2.next = 4;\n                return speakUtterance(ponyfill, _this._utteranceLike, function (cancel) {\n                  if (_this._cancelled) {\n                    cancel();\n                  } else {\n                    _this._cancel = cancel;\n                    _this._utteranceLike.onStart && _this._utteranceLike.onStart(new Event('start'));\n                  }\n                });\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))().then(function () {\n        if (_this._cancelled) {\n          throw new Error('cancelled');\n        }\n      }).then(function () {\n        _this._utteranceLike.onEnd && _this._utteranceLike.onEnd(new Event('end'));\n\n        _this._deferred.resolve();\n      }, function (error) {\n        var event = new Event('error');\n        event.error = error;\n        _this._utteranceLike.onError && _this._utteranceLike.onError(event);\n\n        _this._deferred.reject(error);\n      });\n      return this.promise;\n    }\n  }]);\n  return QueuedUtterance;\n}();\n\nexports[\"default\"] = QueuedUtterance;","map":null,"metadata":{},"sourceType":"script"}